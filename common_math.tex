% TODO: add ensuremath everywhere where appropriate
% TODO: Remove macros already provided by the cool package
% TODO: re-implement physics.sty and braket.sty

\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{cancel}
\usepackage{bm}
\usepackage{cool}
\usepackage{tikz}
\usetikzlibrary{arrows.meta}
\usepackage{xparse}


% Use l3keys to configure style (cf. \Style from the cool package) [[[1
\ExplSyntaxOn

\cs_new:Npn \__wisper_keys_define_math:n #1 { \keys_define:nn { wisper/math } {#1} }
\cs_new:Npn \__wisper_keys_set_math:n #1 { \keys_set:nn { wisper/math } {#1} }
\cs_new_eq:NN \MathStyle \__wisper_keys_set_math:n

\ExplSyntaxOff

% helpers [[[1
% TODO: use DeclarePairedDelimiter, also see
% http://tex.stackexchange.com/questions/23178/swap-definition-of-starred-and-non-starred-command/23214#23214
% http://tex.stackexchange.com/questions/278382/cause-declarepaireddelimiter-to-switch-starred-and-nonstarred-versions
% TODO: cf. `texdoc mathtools` for \parenthesize that is breakable
\newcommand{\parenthesize}[1]{{\left(#1\right)}}
\newcommand{\bracketize}[1]{{\left[#1\right]}}

% stolen from the physics package. Starred versions resize the delimiters
\DeclareDocumentCommand \argopen {s}{%
    \IfBooleanTF{#1}
        {\mathopen{}\mathclose\bgroup}
        {\mathopen{}\mathclose\bgroup\left}
}
\DeclareDocumentCommand \argclose {s}{%
    \IfBooleanTF{#1}
        {\egroup}
        {\aftergroup\egroup\right}
}

% symbols [[[1
% TODO: switch according to language, i.e. Spanish is cte.
\newcommand{\diffd}{\mathrm{d}}
\newcommand{\diffD}{\mathrm{D}}
\newcommand{\const}{\mathrm{const}}


% sets [[[1
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}}
\newcommand{\R}{\ensuremath{\mathbb{R}}}
\newcommand{\Q}{\ensuremath{\mathbb{Q}}}
\newcommand{\C}{\ensuremath{\mathbb{C}}}

\newcommand{\nats}{\N} % natural numbers
\newcommand{\natsz}{\ensuremath{\nats_{\mathrm{0}}}} % natural numbers incl. zero

\newcommand{\Pset}[1]{\ensuremath{\mathcal{P}\left(#1\right)}}


% norms etc. [[[1
\let\Abs\undefined
\DeclarePairedDelimiter\Abs{\lvert}{\rvert}
\DeclarePairedDelimiter\Norm{\lVert}{\rVert}


% Equivalence relations, quotient spaces, ... [[[1
\DeclarePairedDelimiter\EquivalenceClass{\lbrack}{\rbrack}
\let\EqClass\EquivalenceClass


% ranges [[[1
% TODO: let these accept a variable number of initial values, e.g.
% \idxrange{1}[1][2][3][5]{n}
\newcommand{\idxrange}[3]{{#1}_{#2}\dots{#1}_{#3}}
\newcommand{\idxrangec}[3]{{#1}_{#2},\dots,{#1}_{#3}}  % comma-separated
\ExplSyntaxOn
\NewDocumentCommand \Idxrange { m > { \SplitList { , } } m }
  {
    \__wisper_idxrange_aux:nnn {#1} #2 \q_recursion_tail \q_recursion_tail \q_recursion_stop
  }
\cs_new:Npn \__wisper_idxrange_aux:nnn #1#2#3
  {
    %\tl_show:n {#1}
    %\tl_show:n {#2}
    %\tl_show:n {#3}
    \quark_if_recursion_tail_stop:n {#2}
    \__wisper_idxrange_aux:n {#1} {#2}
    % if this was the last item, stop now and do not append a comma
    \quark_if_recursion_tail_stop:n {#3}
    % else append the comma
    ,
    \__wisper_idxrange_aux:nnn {#1} {#3}
  }
\cs_new:Npn \__wisper_idxrange_aux:n #1#2
  {
    \tl_if_eq:nnTF {#2} {.}
      { \dots }
      { {#1} \c_math_subscript_token {#2} }
  }
\ExplSyntaxOff

% complex numbers [[[1
\newcommand{\conj}[1]{#1^{\ast}}


% vectors etc. [[[1


% From https://tex.stackexchange.com/questions/44017/dot-notation-for-derivative-of-a-vector/44071#44071
% --- Macro \xvec
\makeatletter
\newlength\xvec@height%
\newlength\xvec@depth%
\newlength\xvec@width%
\newcommand{\xvec}[2][]{%
    \ifmmode%
        \settoheight{\xvec@height}{$#2$}%
        \settodepth{\xvec@depth}{$#2$}%
        \settowidth{\xvec@width}{$#2$}%
    \else%
        \settoheight{\xvec@height}{#2}%
        \settodepth{\xvec@depth}{#2}%
        \settowidth{\xvec@width}{#2}%
    \fi%
    \def\xvec@arg{#1}%
    \def\xvec@dd{:}%
    \def\xvec@d{.}%
    \raisebox{.1ex}{\raisebox{\xvec@height}{\rlap{%
        \kern.05em%  (Because left edge of drawing is at .05em)
        \begin{tikzpicture}[scale=1]
            \pgfsetroundcap
            %\draw[-{Stealth[width=0.1em, length=0.075em, slant=.3]}] (.05em,0)--(\xvec@width-.05em,0);
            %\draw[-{Straight Barb[left,width=0.1em, length=0.075em, slant=.3]}] (.05em,0)--(\xvec@width-.05em,0);
            \draw[-{Classical TikZ Rightarrow[width=0.2em, length=0.15em, slant=.3]}] (.05em,0)--(\xvec@width-.05em,0);
            %\draw[-{Classical TikZ Rightarrow[left, width=0.2em, length=0.1em, slant=.3]}] (.05em,0)--(\xvec@width-.05em,0);
            %\draw (\xvec@width-.05em,0)--(\xvec@width-.15em, .075em);
            %\draw (\xvec@width-.05em,0)--(\xvec@width-.15em,-.075em);
            \ifx\xvec@arg\xvec@d%
                \fill(\xvec@width*.45,.5ex) circle (.6pt);%
            \else\ifx\xvec@arg\xvec@dd%
                \fill(\xvec@width*.30,.5ex) circle (.6pt);%
                \fill(\xvec@width*.65,.5ex) circle (.6pt);%
            \fi\fi%
        \end{tikzpicture}%
    }}}%
    #2%
}
\makeatother

% Override \vec with an either invocation of \xvec or \bm
\ExplSyntaxOn

\cs_new_eq:NN \stdvec \vec

% TODO: maybe use a property to store the code in order to avoid doubling the '##'
\__wisper_keys_define_math:n
  {
    vecdisplay .choice:,
    vecdisplay / std .code:n =
      {
        \cs_gset_eq:NN \vec \stdvec
        \cs_gset:Npn \uvec ##1 { \hat{\vec{##1}} }
        \cs_gset:Npn \dvec ##1 { \dot{\vec{##1}} }
        \cs_gset:Npn \ddvec ##1 { \ddot{\vec{##1}} }
      },
    vecdisplay / xvec .code:n =
      {
        \cs_gset_eq:NN \vec \xvec
        \cs_gset:Npn \uvec ##1 { \hat{\xvec{##1}} }
        \cs_gset:Npn \dvec ##1 { \xvec[.]{##1} }
        \cs_gset:Npn \ddvec ##1 { \xvec[:]{##1} }
      },
    vecdisplay / bold .meta:n =
      {
        % for some fonts, \bm doesn't do the right thing
        % Maybe \bm does do the right thing after all, the problem was likely due
        % to a messed-up preamble
        % TODO: Automatically select the correct command based on the font
        vecdisplay / bm
      },
    vecdisplay / bm .code:n =
      {
        \cs_gset_eq:NN \vec \bm
        \cs_gset:Npn \uvec ##1 { \bm{\hat{##1}} }
        \cs_gset:Npn \dvec ##1 { \dot{\bm{##1}} }
        \cs_gset:Npn \ddvec ##1 { \ddot{\bm{##1}} }
      },
    vecdisplay / mathbold .code:n =
      {
        \cs_gset_eq:NN \vec \mathbold
        \cs_gset:Npn \uvec ##1 { \mathbold{\hat{##1}} }
        \cs_gset:Npn \dvec ##1 { \dot{\mathbold{##1}} }
        \cs_gset:Npn \ddvec ##1 { \ddot{\mathbold{##1}} }
      },
    vecdisplay .initial:n = bold,
  }

% shorthand
\newcommand\vc{\vec}
\newcommand\dvc{\dvec}
\newcommand\ddvc{\ddvec}
\newcommand\uvc{\uvec}

\newcommand{\colvec}[1]{\begin{pmatrix}#1\end{pmatrix}}

\__wisper_keys_define_math:n
  {
    integrate/displayfunc .choice:,
    integrate/displayfunc / inset .code:n =
      {
        \cs_gset:Npn \__wisper_integrate_integrand:nnn ##1##2##3
          {##1 \mathop{}\!\expandafter\dif\IfValueT{##3}{[##3]}{##2}}
      },
    integrate/displayfunc / outset .code:n =
      {
        \cs_gset:Npn \__wisper_integrate_integrand:nnn ##1##2##3
          {\!\expandafter\dif\IfValueT{##3}{[##3]}{##2}\mathop{}\! ##1}
      },
    integrate/displayfunc .initial:n = inset,
  }

\NewDocumentCommand \IntegrateInternal { m >{\SplitArgument{1}{^}}m m m }
  {
    \IfNoValueTF{#3}
      {\int}
      {\IfNoValueTF{#4}%
          {\int \c_math_subscript_token {#3}}
          {\int \c_math_subscript_token {#3} \c_math_superscript_token {#4}}
      }
    \__wisper_integrate_integrand:nnn {#1} #2
  }

\DeclareDocumentCommand \Integrate{ m >{\SplitArgument{2}{,}}m }{%
    \IntegrateInternal {#1} #2
}

\cs_gset_eq:NN \Int \Integrate

\ExplSyntaxOff

% TODO: port \Sum and \Prod, too, and write starred versions that use \limits
% TODO: \Int{f}{x,1,3;y,0,10}
% TODO: \Iint, \Iiint, \Iiiint, \Idotsint{f(x_1,\ldots,x_n)}{x_1,0,\infty;...;x_j,\R;...;x_n,0,\infty}
% TODO: \Union, \Intersection, \Infimum, \Supremum, \Limes

% COOL prints the '=' also if the second argument is empty...
\NewDocumentCommand\SumInternal{m m m m}{%
    \sum%
    \IfValueT{#2}{_%
        {#2\IfValueT{#3}{%
            \if\relax\detokenize{#3}\relax%
            \else%
                = #3%
            \fi}}%
        }%
    \IfValueT{#4}{^{#4}}%
    #1%
}
\DeclareDocumentCommand\Sum{m >{\SplitArgument{2}{,}}m}{%
    \SumInternal{#1}#2
}

% combinatorics [[[1
% \bincoef{N \\ k}
\newcommand{\bincoef}[1]{\ensuremath{\begin{pmatrix} #1 \end{pmatrix}}}

% operators [[[1
\ExplSyntaxOn
\NewDocumentCommand \Adjoint { m } { {#1}^\dagger }
\cs_new_eq:NN \Adj \Adjoint
\NewDocumentCommand \Operator { m } { \hat{#1} }
\cs_new_eq:NN \Op \Operator
\ExplSyntaxOff

% vector calculus [[[1
\ExplSyntaxOn

\NewDocumentCommand \Gradient { m } { \nabla {#1} }  % not a vector! -> non-bold
\cs_gset_eq:NN \Grad \Gradient

\NewDocumentCommand \Divergence { m } { \vec{\nabla} \cdot {#1} }
\cs_gset_eq:NN \Div \Divergence

\RenewDocumentCommand \Curl { m } { \vec{\nabla} \times {#1} }

\RenewDocumentCommand \Laplacian { m } { \nabla^2 {#1} }  % not a vector! -> non-bold
%\newcommand{\laplacian}{\Delta}
\ExplSyntaxOff


% calculus [[[1

% no-op helper
\NewDocumentCommand\nodifspacing{m}{#1}

% Differential symbol for use in integrals or in differential forms
\NewDocumentCommand\difsymbol{m m o g d()}{%
%\NewDocumentCommand\difsymbol{s m m o g d()}{%
    % {#1} - (star) unstarred: dx³, starred: d³x
    % {#2} - boolean: whether to disable automatic spacing
    % {#3} - the symbol
    % [--] - optional exponent, e.g. d^3 r
    % {#4} - the variable
    % (#5) - long form, e.g. d(cos x)
    \IfBooleanTF{#1}{\let\difspacing\nodifspacing}{\let\difspacing\mathinner}
    \IfNoValueTF{#4}{%
        \IfNoValueTF{#5}{%
% Never apply spacing if no argument is given
            #2 \IfValueT{#3}{^{#3}}
        }{%
% long form
            \difspacing{#2 \IfValueT{#3}{^{#3}} (#5)}
        }
    }{%
% normal form
        \difspacing{#2 \IfValueT{#3}{^{#3}} #4}
    }
}
\DeclareDocumentCommand\dif{s}{\difsymbol{#1}{\diffd}}
\DeclareDocumentCommand\Dif{s}{\difsymbol{#1}{\diffD}}
\DeclareDocumentCommand\del{s}{\difsymbol{#1}{\partial}}
\DeclareDocumentCommand\var{s}{\difsymbol{#1}{\delta}}

% Lebesgue formalism
\newcommand{\leb}{\ensuremath{\lambda}}

% functions [[[1
\newcommand{\func}[1]{\mathrm{#1}}
\newcommand{\expp}[1]{\func{e}^{#1}}
\newcommand{\expb}[1]{\exp\left(#1\right)}
\newcommand{\deltaf}[1]{\func{\delta} (#1)}
\DeclareMathOperator{\asinh}{asinh}

% replace the useless Max{} from the `cool` package
\RenewDocumentCommand\Max{m m}{%
    \max_{#2} \; {#1}%
}

% Derivatives [[[1

% Use gset since `cool` already defines a \pderiv macro
\ExplSyntaxOn
\cs_new:Npn \defineDerivateCommand #1#2
{
    \cs_gset:cpn {#1 deriv} {\deriv{#2}}
    % for convenience, wrap in parenthesis
    \cs_gset:cpn {p #1 deriv} {\deriv[\parenthesize]{#2}}
    % for convenience, wrap in brackets
    \cs_gset:cpn {b #1 deriv} {\deriv[\bracketize]{#2}}
}
\defineDerivateCommand{t}{\dif}
\defineDerivateCommand{p}{\del}
\defineDerivateCommand{f}{\delta}
\ExplSyntaxOff

%------------------------------------------------------------

% TODO: in non-numeric cases, add the integer exponents and join everything with '+'
%   keep the overwrite though (the order might not turn out as intended for example)
%   Also add single-character exponents, i.e {x^n;y^n} -> d^{2n}
\newcounter{derivordercounter}
% example: \deriv{\dif}{f}{x^2;y^3}
% example: \deriv{\partial}{f}{x^n;y^m}[n+m]  with an optional argument to overwrite the count
\NewDocumentCommand \deriv {o m m o >{\SplitList{;}}m} {%
    % #1 - command to wrap the result in (i.e. parenthesis, ...)
    % #2 - deriv sign
    % #3 - function
    % #4 - exponent overwrite for non-numerical cases
    % #5 - semicolon-separated list of variables, exponents given as usual with ^
    \IfValueT{#1}{#1}{%
        \IfNoValueTF{#4}{%
            % no \addtocounter overwrite: determine order, no output yet
            \ProcessList{#5}{\derivcountingsplitter}
            \frac{%
                \ifnum\value{derivordercounter}>1%
                    % nothing, i.e. do not show exponent if it is 1
                    #2^{\thederivordercounter}\!#3
                \else
                    #2 #3
                \fi%
            }{%
                \let\derivsign#2
                \ProcessList{#5}{\derivadd}
            }
            \setcounter{derivordercounter}{0}
        }{%  else
            \frac{#2[#4]\!#3 }{%
                \let\derivsign#2
                \ProcessList{#5}{\derivadd}
            }
        }
    }
}

\NewDocumentCommand \derivcountingsplitter {>{\SplitArgument{1}{^}}m} {%
    \derivcount#1
}

\NewDocumentCommand \derivcount {m m} {%
    \addtocounter{derivordercounter}{\IfNoValueTF{#2}{1}{#2}}
}

\NewDocumentCommand \derivadd {m} {\mathop{}\!\derivsign #1}


% equation numbering [[[1
%http://tex.stackexchange.com/questions/42726/align-but-show-one-equation-number-at-the-end
\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}


% boxes, highlighting, ... [[[1
% https://tex.stackexchange.com/questions/20575/attractive-boxed-equations


% Quick quad text (math-mode text with \quad spacing). [[[1
% Stolen from the physics package.
\DeclareDocumentCommand\qqmathinternal{m m}{\IfBooleanTF{#1}{}{\quad}{#2}\quad}
\DeclareDocumentCommand\qqtextinternal{m m}{\qqmathinternal{#1}{\textnormal{#2}}}
\DeclareDocumentCommand\qqtext{s m}{\qqtextinternal{#1}{#2}}
\DeclareDocumentCommand\qqmath{s m}{\qqmathinternal{#1}{#2}}

\DeclareDocumentCommand\qq{}{\qqtext}

\DeclareDocumentCommand\qcomma{}{,\quad}
\DeclareDocumentCommand\qc{}{\qcomma}

\DeclareDocumentCommand\qimplies{s}{\qqmathinternal{#1}{\implies}}

\DeclareDocumentCommand\qif{s}{\qqtextinternal{#1}{if}}
\DeclareDocumentCommand\qthen{s}{\qqtextinternal{#1}{then}}
\DeclareDocumentCommand\qelse{s}{\qqtextinternal{#1}{else}}
\DeclareDocumentCommand\qotherwise{s}{\qqtextinternal{#1}{otherwise}}
\DeclareDocumentCommand\qunless{s}{\qqtextinternal{#1}{unless}}
\DeclareDocumentCommand\qgiven{s}{\qqtextinternal{#1}{given}}
\DeclareDocumentCommand\qusing{s}{\qqtextinternal{#1}{using}}
\DeclareDocumentCommand\qassume{s}{\qqtextinternal{#1}{assume}}
\DeclareDocumentCommand\qsince{s}{\qqtextinternal{#1}{since}}
\DeclareDocumentCommand\qlet{s}{\qqtextinternal{#1}{let}}
\DeclareDocumentCommand\qfor{s}{\qqtextinternal{#1}{for}}
\DeclareDocumentCommand\qall{s}{\qqtextinternal{#1}{all}}
\DeclareDocumentCommand\qeven{s}{\qqtextinternal{#1}{even}}
\DeclareDocumentCommand\qodd{s}{\qqtextinternal{#1}{odd}}
\DeclareDocumentCommand\qinteger{s}{\qqtextinternal{#1}{integer}}
\DeclareDocumentCommand\qand{s}{\qqtextinternal{#1}{and}}
\DeclareDocumentCommand\qor{s}{\qqtextinternal{#1}{or}}
\DeclareDocumentCommand\qas{s}{\qqtextinternal{#1}{as}}
\DeclareDocumentCommand\qin{s}{\qqtextinternal{#1}{in}}
\DeclareDocumentCommand\qcc{s}{\qqtextinternal{#1}{c.c.}}

% vim: ts=2 sw=2 et fdm=marker fmr=[[[,]]]:
