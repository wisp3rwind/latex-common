% TODO: add ensuremath everywhere where appropriate
% TODO: Remove macros already provided by the cool package

\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{cancel}
\usepackage{bm}
\usepackage{cool}
\usepackage{tikz}
\usetikzlibrary{arrows.meta}
\usepackage{pgfkeys}


% Use pgfkeys to configure style (cf. \Style from the cool package) [[[1
\newcommand{\MathStyle}[1]{\pgfqkeys{/math/notation}{#1}}

% helpers [[[1
% TODO: use DeclarePairedDelimiter, also see
% http://tex.stackexchange.com/questions/23178/swap-definition-of-starred-and-non-starred-command/23214#23214
% http://tex.stackexchange.com/questions/278382/cause-declarepaireddelimiter-to-switch-starred-and-nonstarred-versions
\newcommand{\parenthesize}[1]{{\left(#1\right)}}
\newcommand{\bracketize}[1]{{\left[#1\right]}}

% stolen from the physics package. Starred versions resize the delimiters
\DeclareDocumentCommand \argopen {s}{%
    \IfBooleanTF{#1}
        {\mathopen{}\mathclose\bgroup}
        {\mathopen{}\mathclose\bgroup\left}
}
\DeclareDocumentCommand \argclose {s}{%
    \IfBooleanTF{#1}
        {\egroup}
        {\aftergroup\egroup\right}
}

% symbols [[[1
% TODO: switch according to language, i.e. Spanish is cte.
\newcommand{\diffd}{\mathrm{d}}
\newcommand{\diffD}{\mathrm{D}}
\newcommand{\const}{\mathrm{const}}


% sets [[[1
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}}
\newcommand{\R}{\ensuremath{\mathbb{R}}}
\newcommand{\Q}{\ensuremath{\mathbb{Q}}}
\newcommand{\C}{\ensuremath{\mathbb{C}}}

\newcommand{\nats}{\N} % natural numbers
\newcommand{\natsz}{\ensuremath{\nats_{\mathrm{0}}}} % natural numbers incl. zero

\newcommand{\Pset}[1]{\ensuremath{\mathcal{P}\left(#1\right)}}


% norms etc. [[[1
\let\Abs\undefined
\DeclarePairedDelimiter\abs{\lvert}{\rvert}
\DeclarePairedDelimiter\Abs{\left\lvert}{\right\rvert}
\DeclarePairedDelimiter\norm{\lVert}{\rVert}
\DeclarePairedDelimiter\Norm{\left\lVert}{\right\rVert}


% ranges [[[1
% TODO: let these accept a variable number of initial values, e.g.
% \idxrange{1}[1][2][3][5]{n}
\newcommand{\idxrange}[3]{{#1}_{#2}\dots{#1}_{#3}}
\newcommand{\idxrangec}[3]{{#1}_{#2},\dots,{#1}_{#3}}  % comma-separated

% complex numbers [[[1
\newcommand{\conj}[1]{#1^{\ast}}


% vectors etc. [[[1


% From https://tex.stackexchange.com/questions/44017/dot-notation-for-derivative-of-a-vector/44071#44071
% --- Macro \xvec
\makeatletter
\newlength\xvec@height%
\newlength\xvec@depth%
\newlength\xvec@width%
\newcommand{\xvec}[2][]{%
    \ifmmode%
        \settoheight{\xvec@height}{$#2$}%
        \settodepth{\xvec@depth}{$#2$}%
        \settowidth{\xvec@width}{$#2$}%
    \else%
        \settoheight{\xvec@height}{#2}%
        \settodepth{\xvec@depth}{#2}%
        \settowidth{\xvec@width}{#2}%
    \fi%
    \def\xvec@arg{#1}%
    \def\xvec@dd{:}%
    \def\xvec@d{.}%
    \raisebox{.1ex}{\raisebox{\xvec@height}{\rlap{%
        \kern.05em%  (Because left edge of drawing is at .05em)
        \begin{tikzpicture}[scale=1]
            \pgfsetroundcap
            %\draw[-{Stealth[width=0.1em, length=0.075em, slant=.3]}] (.05em,0)--(\xvec@width-.05em,0);
            %\draw[-{Straight Barb[left,width=0.1em, length=0.075em, slant=.3]}] (.05em,0)--(\xvec@width-.05em,0);
            \draw[-{Classical TikZ Rightarrow[width=0.2em, length=0.15em, slant=.3]}] (.05em,0)--(\xvec@width-.05em,0);
            %\draw[-{Classical TikZ Rightarrow[left, width=0.2em, length=0.1em, slant=.3]}] (.05em,0)--(\xvec@width-.05em,0);
            %\draw (\xvec@width-.05em,0)--(\xvec@width-.15em, .075em);
            %\draw (\xvec@width-.05em,0)--(\xvec@width-.15em,-.075em);
            \ifx\xvec@arg\xvec@d%
                \fill(\xvec@width*.45,.5ex) circle (.6pt);%
            \else\ifx\xvec@arg\xvec@dd%
                \fill(\xvec@width*.30,.5ex) circle (.6pt);%
                \fill(\xvec@width*.65,.5ex) circle (.6pt);%
            \fi\fi%
        \end{tikzpicture}%
    }}}%
    #2%
}
\makeatother

% Override \vec with an either invocation of \xvec or \bm
\let\stdvec\vec
\newcommand\uvec{}  % dummy
\newcommand\dvec{}  % dummy
\newcommand\ddvec{}  % dummy
\MathStyle{%
    vecdisplay/.is choice,
    vecdisplay/std/.code={%
        \renewcommand{\vec}[1]{\stdvec{##1}}
        \renewcommand{\uvec}[1]{\hat{\vec{##1}}}
        \renewcommand{\dvec}[1]{\dot{\stdvec{##1}}}
        \renewcommand{\ddvec}[1]{\ddot{\stdvec{##1}}}
    },
    vecdisplay/xvec/.code={%
        \renewcommand{\vec}[1]{\xvec[]{##1}}
        \renewcommand{\uvec}[1]{\hat{\vec{##1}}}
        \renewcommand{\dvec}[1]{\xvec[.]{##1}}
        \renewcommand{\ddvec}[1]{\xvec[:]{##1}}
    },
    vecdisplay/bold/.style={%
        % for some fonts, \bm doesn't do the right thing
        % Maybe \bm does do the right thing after all, the problem was likely due
        % to a messed-up preamble
        % TODO: Automatically select the correct command based on the font
        vecdisplay/bm
    },
    vecdisplay/bm/.code={%
        \renewcommand{\vec}[1]{\bm{##1}}
        \renewcommand{\uvec}[1]{\bm{\hat{##1}}}
        \renewcommand{\dvec}[1]{\dot{\bm{##1}}}
        \renewcommand{\ddvec}[1]{\ddot{\bm{##1}}}
    },
    vecdisplay/mathbold/.code={%
        \renewcommand{\vec}[1]{\mathbold{##1}}
        \renewcommand{\uvec}[1]{\mathbold{\hat{##1}}}
        \renewcommand{\dvec}[1]{\dot{\mathbold{##1}}}
        \renewcommand{\ddvec}[1]{\ddot{\mathbold{##1}}}
    },
}
\MathStyle{vecdisplay=bold}

% shorthand
\newcommand\vc{\vec}
\newcommand\dvc{\dvec}
\newcommand\ddvc{\ddvec}
\newcommand\uvc{\uvec}

\newcommand{\colvec}[1]{\begin{pmatrix}#1\end{pmatrix}}

\MathStyle{%
    integrate/displayfunc/.is choice,
    integrate/displayfunc/inset/.style={%
        integrate/integrand/.code n args={3}{##1 \dif[##3]{##2}}
    },
    integrate/displayfunc/outset/.style={%
        integrate/integrand/.code n args={3}{\!\dif[##3]{##2} ##1}
    },
}
\MathStyle{integrate/displayfunc=inset}
\NewDocumentCommand\IntegrateInternalIntegrand{m m m}{%
    \MathStyle{integrate/integrand={#1}{#2}{#3}}
}
\NewDocumentCommand\IntegrateInternal{m >{\SplitArgument{1}{^}}m m m}{%
    \IfNoValueTF{#3}
        {\int}
        {\IfNoValueTF{#4}%
            {\int_{#3}}
            {\int_{#3}^{#4}}
        }
    \IntegrateInternalIntegrand{#1}#2
}
\DeclareDocumentCommand\Integrate{m >{\SplitArgument{2}{,}}m}{%
    \IntegrateInternal{#1}#2
}

\DeclareDocumentCommand\Int{}{\Integrate}

% COOL prints the '=' also if the second argument is empty...
\NewDocumentCommand\SumInternal{m m m m}{%
    \sum%
    \IfValueT{#2}{_%
        {#2\IfValueT{#3}{%
            \if\relax\detokenize{#3}\relax%
            \else%
                = #3%
            \fi}}%
        }%
    \IfValueT{#4}{^{#4}}%
    #1%
}
\DeclareDocumentCommand\Sum{m >{\SplitArgument{2}{,}}m}{%
    \SumInternal{#1}#2
}

% combinatorics [[[1
% \bincoef{N \\ k}
\newcommand{\bincoef}[1]{\ensuremath{\begin{pmatrix} #1 \end{pmatrix}}}

% operators [[[1
\newcommand{\adj}[1]{#1^{\dagger}}
\newcommand{\op}[1]{\hat{#1}}

% vector calculus [[[1
\newcommand{\vecnabla}{\vec{\nabla}}
\newcommand{\grad}{\nabla}  % not a vector! -> non-bold
\renewcommand{\div}{\vecnabla\cdot}
\newcommand{\curl}{\vecnabla\times}
\newcommand{\laplacian}{\nabla^2}  % not a vector! -> non-bold
%\newcommand{\laplacian}{\Delta}


% calculus [[[1

% no-op helper
\NewDocumentCommand\nodifspacing{m}{#1}

% Differential symbol for use in integrals or in differential forms
\NewDocumentCommand\difsymbol{m m o g d()}{%
    % {#1} - boolean: whether to disable automatic spacing
    % {#2} - the symbol
    % [#3] - optional exponent, e.g. d^3 r
    % {#4} - the variable
    % (#5) - long form, e.g. d(cos x)
    \IfBooleanTF{#1}{\let\difspacing\nodifspacing}{\let\difspacing\mathinner}
    \IfNoValueTF{#4}{%
        \IfNoValueTF{#5}{%
% Never apply spacing if no argument is given
            #2 \IfValueT{#3}{^{#3}}
        }{%
% long form
            \difspacing{#2 \IfValueT{#3}{^{#3}} (#5)}
        }
    }{%
% normal form
        \difspacing{#2 \IfValueT{#3}{^{#3}} #4}
    }
}
\DeclareDocumentCommand\dif{s}{\difsymbol{#1}{\diffd}}
\DeclareDocumentCommand\Dif{s}{\difsymbol{#1}{\diffD}}
\DeclareDocumentCommand\del{s}{\difsymbol{#1}{\partial}}
\DeclareDocumentCommand\var{s}{\difsymbol{#1}{\delta}}

% Lebesgue formalism
\newcommand{\leb}{\ensuremath{\lambda}}

% functions [[[1
\newcommand{\func}[1]{\mathrm{#1}}
\newcommand{\expp}[1]{\func{e}^{#1}}
\newcommand{\expb}[1]{\exp\left(#1\right)}
\newcommand{\deltaf}[1]{\func{\delta} (#1)}
\DeclareMathOperator{\asinh}{asinh}

% replace the useless Max{} from the `cool` package
\RenewDocumentCommand\Max{m m}{%
    \max_{#2} \; {#1}%
}

% Derivatives [[[1

% Use renewcommand since `cool` already defines a \pderiv macro
\newcommand\defineDerivateCommand[2]{%
    \expandafter\providecommand\csname #1\endcsname{\deriv{#2}}
    \expandafter\renewcommand\csname #1\endcsname{\deriv{#2}}
    % for convenience, wrap in parenthesis
    \expandafter\providecommand\csname p#1\endcsname{\deriv[\parenthesize]{#2}}
    \expandafter\renewcommand\csname p#1\endcsname{\deriv[\parenthesize]{#2}}
    % for convenience, wrap in brackets
    \expandafter\providecommand\csname b#1\endcsname{\deriv[\bracketize]{#2}}
    \expandafter\renewcommand\csname b#1\endcsname{\deriv[\bracketize]{#2}}
}
\defineDerivateCommand{tderiv}{\dif}
\defineDerivateCommand{pderiv}{\del}
\defineDerivateCommand{fderiv}{\delta}

%------------------------------------------------------------

% TODO: in non-numeric cases, add the integer exponents and join everything with '+'
%   keep the overwrite though (the order might not turn out as intended for example)
%   Also add single-character exponents, i.e {x^n;y^n} -> d^{2n}
\newcounter{derivordercounter}
% example: \deriv{\dif}{f}{x^2;y^3}
% example: \deriv{\partial}{f}{x^n;y^m}[n+m]  with an optional argument to overwrite the count
\NewDocumentCommand \deriv {o m m o >{\SplitList{;}}m} {%
    % #1 - command to wrap the result in (i.e. parenthesis, ...)
    % #2 - deriv sign
    % #3 - function
    % #4 - exponent overwrite for non-numerical cases
    % #5 - semicolon-separated list of variables, exponents given as usual with ^
    \IfValueT{#1}{#1}{%
        \IfNoValueTF{#4}{%
            % no \addtocounter overwrite: determine order, no output yet
            \ProcessList{#5}{\derivcountingsplitter}
            \frac{%
                \ifnum\value{derivordercounter}>1%
                    % nothing, i.e. do not show exponent if it is 1
                    #2^{\thederivordercounter}\!#3
                \else
                    #2 #3
                \fi%
            }{%
                \let\derivsign#2
                \ProcessList{#5}{\derivadd}
            }
            \setcounter{derivordercounter}{0}
        }{%  else
            \frac{#2[#4]\!#3 }{%
                \let\derivsign#2
                \ProcessList{#5}{\derivadd}
            }
        }
    }
}

\NewDocumentCommand \derivcountingsplitter {>{\SplitArgument{1}{^}}m} {%
    \derivcount#1
}

\NewDocumentCommand \derivcount {m m} {%
    \addtocounter{derivordercounter}{\IfNoValueTF{#2}{1}{#2}}
}

\NewDocumentCommand \derivadd {m} {\mathop{}\!\derivsign #1}


% equation numbering [[[1
%http://tex.stackexchange.com/questions/42726/align-but-show-one-equation-number-at-the-end
\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}


% boxes, highlighting, ... [[[1
% https://tex.stackexchange.com/questions/20575/attractive-boxed-equations


% Quick quad text (math-mode text with \quad spacing). [[[1
% Stolen from the physics package.
\DeclareDocumentCommand\qqtextinternal{m m}{\IfBooleanTF{#1}{}{\quad}\textnormal{#2}\quad}
\DeclareDocumentCommand\qqtext{s m}{\qqtextinternal{#1}{#2}}
\DeclareDocumentCommand\qq{}{\qqtext}

\DeclareDocumentCommand\qcomma{}{,\quad}
\DeclareDocumentCommand\qc{}{\qcomma}

\DeclareDocumentCommand\qif{s}{\qqtextinternal{#1}{if}}
\DeclareDocumentCommand\qthen{s}{\qqtextinternal{#1}{then}}
\DeclareDocumentCommand\qelse{s}{\qqtextinternal{#1}{else}}
\DeclareDocumentCommand\qotherwise{s}{\qqtextinternal{#1}{otherwise}}
\DeclareDocumentCommand\qunless{s}{\qqtextinternal{#1}{unless}}
\DeclareDocumentCommand\qgiven{s}{\qqtextinternal{#1}{given}}
\DeclareDocumentCommand\qusing{s}{\qqtextinternal{#1}{using}}
\DeclareDocumentCommand\qassume{s}{\qqtextinternal{#1}{assume}}
\DeclareDocumentCommand\qsince{s}{\qqtextinternal{#1}{since}}
\DeclareDocumentCommand\qlet{s}{\qqtextinternal{#1}{let}}
\DeclareDocumentCommand\qfor{s}{\qqtextinternal{#1}{for}}
\DeclareDocumentCommand\qall{s}{\qqtextinternal{#1}{all}}
\DeclareDocumentCommand\qeven{s}{\qqtextinternal{#1}{even}}
\DeclareDocumentCommand\qodd{s}{\qqtextinternal{#1}{odd}}
\DeclareDocumentCommand\qinteger{s}{\qqtextinternal{#1}{integer}}
\DeclareDocumentCommand\qand{s}{\qqtextinternal{#1}{and}}
\DeclareDocumentCommand\qor{s}{\qqtextinternal{#1}{or}}
\DeclareDocumentCommand\qas{s}{\qqtextinternal{#1}{as}}
\DeclareDocumentCommand\qin{s}{\qqtextinternal{#1}{in}}
\DeclareDocumentCommand\qcc{s}{\qqtextinternal{#1}{c.c.}}

% vim: ts=4 sw=4 et fdm=marker fmr=[[[,]]]:
