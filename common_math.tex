% TODO: add ensuremath everywhere where appropriate
% TODO: Remove macros already provided by the cool package
% TODO: re-implement physics.sty and braket.sty
% TODO: Consistency: ensure that starred versions of commands only ever mean resizing version
% and nothing else
% TODO: support \Op[\big] syntax to override size for as many commands as possible
% TODO: documentation
% TODO: make as many commands as possible expandable, properly protect everything else

\usepackage{xparse}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{cancel}
\usepackage{bm}
\usepackage{cool}
\usepackage{tikz}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{calc,arrows.meta,bending}  % current texlive version of witharrows fails to load if not preloading these...
\usepackage{witharrows}
\WithArrowsOptions{displaystyle}
\usepackage{xcolor}
\usepackage{empheq}
\usepackage{tensor}


% Use l3keys to configure style (cf. \Style from the cool package) [[[1
\ExplSyntaxOn

\cs_new:Npn \__wisper_keys_define_math:n #1 { \keys_define:nn { wisper/math } {#1} }
\cs_new:Npn \__wisper_keys_set_math:n #1 { \keys_set:nn { wisper/math } {#1} }
\cs_new:Npn \__wisper_keys_set_math:nn #1#2 { \keys_set:nn { wisper/math/#1 } {#2} }
\cs_new:Npn \__wisper_keys_set_known_math:nnN #1#2#3 { \keys_set_known:nnN { wisper/math/#1 } {#2} #3 }
\cs_new_eq:NN \MathStyle \__wisper_keys_set_math:n

\cs_new:Npn \__wisper_key_define_surrounding:nnn #1#2#3
  {
    \__wisper_keys_define_math:n
      {
        % TODO: shortcuts
        #1 .choice:,
        #1 / parenthesis .code:n =
          {
            \cs_set_eq:cN { #2:nnn } \__wisper_parenthesize:nnn
            \cs_set_eq:cN { #2:nn } \__wisper_parenthesize:nn
            \cs_set_eq:cN { #2_resize:n } \__wisper_parenthesize_resize:n
          },
        #1 / parenthesis-alt .code:n =
          {
            \cs_set_eq:cN { #2:nnn } \__wisper_parenthesize_alt:nnn
            \cs_set_eq:cN { #2:nn } \__wisper_parenthesize_alt:nn
            \cs_set_eq:cN { #2_resize:n } \__wisper_parenthesize_alt_resize:n
          },
        #1 / braces .code:n =
          {
            \cs_set_eq:cN { #2:nnn } \__wisper_embrace:nnn
            \cs_set_eq:cN { #2:nn } \__wisper_embrace:nn
            \cs_set_eq:cN { #2_resize:n } \__wisper_embrace_resize:n
          },
        #1 / brackets .code:n =
          {
            \cs_set_eq:cN { #2:nnn } \__wisper_bracketize:nnn
            \cs_set_eq:cN { #2:nn } \__wisper_bracketize:nn
            \cs_set_eq:cN { #2_resize:n } \__wisper_bracketize_resize:n
          },
        #1 / none .code:n =
          {
            \cs_set_eq:cN { #2:nnn } \__wisper_surround_none:nnn
            \cs_set_eq:cN { #2:nn } \__wisper_surround_none:nn
            \cs_set_eq:cN { #2_resize:n } \__wisper_surround_none_resize:n
          },
        #1 .initial:n = #3,
      }
  }

% Variants, Additions to l3kernel and non math-specific helpers [[[1

%\cs_new:Npn \exp_last_unbraced:NcNo
%  { \::c \::N \::o_unbraced \::: }
%\cs_new:Npn \exp_last_unbraced:NcNo #1#2#3#4
%  { \exp_after:wN #1 \cs:w #2 \exp_after:wN \cs_end: \exp_after:wN #3 #4 }
\cs_generate_variant:Nn \tl_if_novalue:nF { VF }

% clist tools [[[2
% Copy & pasted \clist_map_inline:nn with slight modification to prevent unbracing
% the items. Somewhat simplified since I only need one variant (:nn and not :Nn)
\cs_new:Npn \__wisper_null {}  % vanishes after one expansion
\cs_new:Npn \__wisper_clist_map_function_no_unbrace:Nw #1#2 ,
  {
    % The first token in #2 is \__wisper_null, expand that once so it vanishes
    \exp_after:wN \quark_if_recursion_tail_break:nN
      \exp_after:wN {#2}
      \clist_map_break:
    \exp_after:wN #1
      \exp_after:wN {#2}
    \__wisper_clist_map_function_no_unbrace:Nw #1 \__wisper_null
  }
\int_new:N \g__wisper_prg_map_int
\cs_new_protected:Npn \__wisper_clist_map_inline_no_unbrace:nn #1#2
  {
    \int_gincr:N \g__wisper_prg_map_int
    \cs_gset_protected:cpn
      { __wisper_prg_map_ \int_use:N \g__wisper_prg_map_int :w } ##1 {#2}
    \exp_args:Nc \__wisper_clist_map_function_no_unbrace:Nw
      { __wisper_prg_map_ \int_use:N \g__wisper_prg_map_int :w }
      \__wisper_null #1 , \q_recursion_tail ,
    \prg_break_point:Nn \clist_map_break:
      { \int_gdecr:N \g__wisper_prg_map_int }
  }
\cs_new:Npn \__wisper_clist_to_args_no_unbrace:w #1 , #2 \q_stop
  {
    % expand the null marker and leave the result in the input stream
    \exp_after:wN \exp_not:n \exp_after:wN {#2}
    \tl_if_empty:nF {#2}
      {
        \__wisper_clist_to_args_no_unbrace:w \__wisper_null #2
      }
  }
\cs_new:Npn \__wisper_clist_to_args_no_unbrace:n #1
  {
    \__wisper_clist_to_args_no_unbrace:w \__wisper_null #1 , \q_stop
  }

% Use xparse in a programmatic manner [[[2
\cs_gset_eq:NN \__wisper_new_document_command:Nnn \NewDocumentCommand
\cs_gset_eq:NN \__wisper_declare_document_command:Nnn \DeclareDocumentCommand
\cs_generate_variant:Nn \__wisper_new_document_command:Nnn { cnn }
\cs_generate_variant:Nn \__wisper_declare_document_command:Nnn { cnn }

\regex_gset:Nn \g__wisper_integer_regex { \A[+\-]?\d+\Z }
\prg_new_protected_conditional:Npnn \__wisper_if_integer:n #1 { T, F, TF }
  {
    %\tl_show:n {#1}
    \regex_match:NnTF \g__wisper_integer_regex {#1}
      { \prg_return_true: }
      { \prg_return_false: }
  }
\cs_generate_variant:Nn \__wisper_if_integer:nTF { xTF }

\prg_new_conditional:Npnn \__wisper_tl_if_novalue_or_blank:n #1 { p, T, F, TF }
  {
    \bool_if:nTF { \tl_if_novalue_p:n {#1} || \tl_if_blank_p:n {#1} }
      { \prg_return_true: } { \prg_return_false: }
  }
\prg_generate_conditional_variant:Nnn \__wisper_tl_if_novalue_or_blank:n { V } { p, T, F, TF }

% helpers [[[1
% TODO: use DeclarePairedDelimiter, also see
% http://tex.stackexchange.com/questions/23178/swap-definition-of-starred-and-non-starred-command/23214#23214
% http://tex.stackexchange.com/questions/278382/cause-declarepaireddelimiter-to-switch-starred-and-nonstarred-versions
% TODO: cf. `texdoc mathtools` for \parenthesize that is breakable
%\newcommand{\parenthesize}[1]{{\left(#1\right)}}
%\newcommand{\bracketize}[1]{{\left[#1\right]}}

% symbols [[[1
% TODO: switch according to language, i.e. Spanish is cte.
\cs_new:Npn \diffd { \mathrm{ d } }
\cs_new:Npn \diffD { \mathrm{ D } }
\cs_new:Npn \const { \mathrm{ const } }

% TODO: use for all appropriate operators
\cs_new:Npn \__wisper_argument_or_empty:n #1
  {
    \tl_if_empty:nTF {#1}
      { \: \cdot \: }
      {#1}
  }


% maps [[[1
\DeclareMathOperator { \__wisper_operator_image: } { Im }
\NewDocumentCommand \Image { s }
  {
    \__wisper_operator_image: \__wisper_parenthesize:nn {#1}
  }

\cs_new:Npn \__wisper_declare_paired_delimiter:nNN #1#2#3
  {
    \exp_args:Nc \DeclarePairedDelimiter { #1 _aux:w } #2 #3
    \cs_new:cpx { #1 :nnn } ##1##2
      {
        \exp_not:N \IfBooleanTF {##1}
          { \exp_not:c { #1 _aux:w } * }
          {
            \exp_not:N \__wisper_tl_if_novalue_or_blank:nTF {##2}
              { \exp_not:c { #1 _aux:w } }
              { \exp_not:c { #1 _aux:w } [##2] }
          }
      }
    \cs_new:cpx { #1 :nn } ##1
      {
        \exp_not:N \IfBooleanTF {##1}
          { \exp_not:c { #1 _aux:w } * }
          { \exp_not:c { #1 _aux:w } }
      }
    \cs_new:cpx { #1 _resize:n }
      {
        \exp_not:c { #1 _aux:w } * 
      }
  }

\__wisper_declare_paired_delimiter:nNN { __wisper_bracketize } \lbrack \rbrack
\__wisper_declare_paired_delimiter:nNN { __wisper_embrace } \lbrace \rbrace
\__wisper_declare_paired_delimiter:nNN { __wisper_parenthesize } \lparen \rparen
\__wisper_declare_paired_delimiter:nNN { __wisper_parenthesize_alt } \lgroup \rgroup
\cs_new:Npn \__wisper_surround_none:w
  {
    \peek_charcode_remove_ignore_spaces:NTF *
    % TODO: There should probably be some grouping here
      { \use:n }
      { \use:n }
  }
\cs_new:Npn \__wisper_surround_none:nnn #1#2#3
  { #3 }
\cs_new:Npn \__wisper_surround_none:nn #1#2
  { #2 }

\tl_new:N \g__wisper_symbol_trace_tl
\prop_new:N \g__wisper_symbol_trace_prop
\DeclareMathOperator \__wisper_operator_trace_tr: { tr }
\DeclareMathOperator \__wisper_operator_trace_Tr: { Tr }
\prop_put:Nnn \g__wisper_symbol_trace_prop { tr } { \__wisper_operator_trace_tr: }
\prop_put:Nnn \g__wisper_symbol_trace_prop { Tr } { \__wisper_operator_trace_Tr: }
\__wisper_keys_define_math:n
  {
    trace / symbol .code:n =
      {
        \prop_if_in:NnTF \g__wisper_symbol_trace_prop {#1}
          {
            \prop_get:NnN \g__wisper_symbol_trace_prop {#1} \__wisper_operator_trace:
          }
          {
            \msg_error:
          }
      },
    trace / symbol .value_required:n = true,
    trace / symbol .initial:n = Tr,

    trace / options / space .tl_set:N = \l__wisper_trace_space_tl,
  }
\__wisper_key_define_surrounding:nnn { trace / surrounding }
  { __wisper_operator_trace_surrounding }
  { braces }
\cs_generate_variant:Nn \__wisper_operator_trace_surrounding:nnn { nVn }
\NewDocumentCommand \Trace { s o m }
  {
    \__wisper_operator_trace:

    \tl_clear:N \l__wisper_trace_space_tl
    \tl_clear:N \l_tmpa_tl
    \IfNoValueF { #2 }
      {
        \__wisper_keys_set_known_math:nnN { trace / options } { #2 } \l_tmpa_tl
        \__wisper_tl_if_novalue_or_blank:VF \l__wisper_trace_space_tl
          { \c_math_subscript_token { \l__wisper_trace_space_tl } }
      }
    \__wisper_operator_trace_surrounding:nVn { #1 } \l_tmpa_tl { #3 }
  }
\cs_gset_eq:NN \Tr \Trace

\tl_new:N \g__wisper_symbol_identity_tl
\prop_new:N \g__wisper_symbol_identity_prop
\prop_put:Nnn \g__wisper_symbol_identity_prop { id } {\mathrm{id}}
\prop_put:Nnn \g__wisper_symbol_identity_prop { 1 } {\mathbb{1}}
\prop_put:Nnn \g__wisper_symbol_identity_prop { I } {\bm{\mathrm{I}}}
\__wisper_keys_define_math:n
  {
    symbols / identity .code:n =
      {
        \prop_if_in:NnTF \g__wisper_symbol_identity_prop {#1}
          {
            \prop_get:NnN \g__wisper_symbol_identity_prop {#1} \g__wisper_symbol_identity_tl
          }
          {
            \msg_error:
          }
      },
    symbols / identity .value_required:n = true,
    symbols / identity .initial:n = I,
  }
\NewDocumentCommand \id { }
  {
    \ensuremath{\g__wisper_symbol_identity_tl}
  }

% misc [[[1
\newcommand{\supposed}{\stackrel{!}{=}}
\DeclareMathOperator { \__wisper_operator_order: }{ \mathcal{O} }
\NewDocumentCommand \Order { s }
  {
    \__wisper_operator_order: \__wisper_parenthesize:nn {#1}
  }

% sets [[[1
\cs_new:Npn \N { \ensuremath{\mathbb{N}} }  % natural numbers
\cs_new:Npn \Z { \ensuremath{\mathbb{Z}} }  % integers
\cs_new:Npn \R { \ensuremath{\mathbb{R}} }  % real numbers
\cs_new:Npn \Q { \ensuremath{\mathbb{Q}} }  % rational numbers
\cs_new:Npn \C { \ensuremath{\mathbb{C}} }  % complex numbers
%\cs_new:Npn \Sphere { \ensuremath{\mathbb{S}} }  % \S^n \subset \R^{n+1}
\cs_new:Npn \Sphere { \ensuremath{S} }  % \S^n \subset \R^{n+1}

\cs_gset_eq:NN \nats \N % natural numbers
\cs_new:Npn \natsz { \ensuremath{\nats_{\mathrm{0}}} } % natural numbers incl. zero

\cs_new:Npn \Pset #1 { \ensuremath{\mathcal{P} \__wisper_parenthesize_aux:w {#1} } }


\cs_new:Npn \__wisper_mid_vert:n #1
  {
    % TODO: understand this spacing construction (specfically look up \nonscript)
    \nonscript\:
    #1\vert
    \allowbreak
    \nonscript\:
    \mathopen{}
  }

\DeclarePairedDelimiterX \__wisper_set:wn [1] \lbrace \rbrace
  {
    \cs_set:Npn \given { \__wisper_mid_vert:n { \delimsize } }
    %\nonscript\, #1 \nonscript\,
    \nonscript #1 \nonscript
  }
\cs_gset_eq:NN \Set \__wisper_set:wn

\cs_new_eq:NN \union \cup
\cs_new_eq:NN \intersection \cap


% norms etc. [[[1
\cs_undefine:N \Abs
\DeclarePairedDelimiterX \Abs[1] \lvert \rvert
{ \__wisper_argument_or_empty:n {#1} }

\DeclarePairedDelimiterX \Norm[1] \lVert \rVert
{ \__wisper_argument_or_empty:n {#1} }

\DeclarePairedDelimiterX \ExpectationValue[1] \langle \rangle
{ \__wisper_argument_or_empty:n {#1} }
\cs_gset_eq:NN \ExpVal \ExpectationValue

\DeclarePairedDelimiterX \InnerProduct[2] \langle \rangle
{ \__wisper_argument_or_empty:n {#1} , \__wisper_argument_or_empty:n {#2} }
\cs_gset_eq:NN \IProd \InnerProduct

\cs_undefine:N \Floor
\DeclarePairedDelimiterX \Floor[2] \lfloor \rfloor
{ \__wisper_argument_or_empty:n {#1} , \__wisper_argument_or_empty:n {#2} }

\cs_undefine:N \Ceil
\DeclarePairedDelimiterX \Ceil[2] \lceil \rceil
{ \__wisper_argument_or_empty:n {#1} , \__wisper_argument_or_empty:n {#2} }


% Equivalence relations, quotient spaces, ... [[[1
\cs_gset_eq:NN \EquivalenceClass \__wisper_bracketize_aux:w
\cs_gset_eq:NN \EqClass \EquivalenceClass


% ranges [[[1
% TODO: let these accept a variable number of initial values, e.g.
% \idxrange{1}[1][2][3][5]{n}
\cs_new:Npn \idxrange #1#2#3
  {
    {#1} \c_math_subscript_token {#2}
    \dots
    {#1} \c_math_subscript_token {#3}
  }
\cs_new:Npn \idxrangec #1#2#3
  {
    {#1} \c_math_subscript_token {#2},
    \dots,
    {#1} \c_math_subscript_token {#3}
  }  % comma-separated

\NewDocumentCommand \Idxrange { s m > { \SplitList { , } } m }
  {
    \__wisper_idxrange_aux:nnnn {#1} {#2} #3 \q_recursion_tail \q_recursion_tail \q_recursion_stop
  }
\cs_new:Npn \__wisper_idxrange_aux:nnnn #1#2#3#4
  {
    %\tl_show:n {#2}
    %\tl_show:n {#3}
    %\tl_show:n {#4}
    \quark_if_recursion_tail_stop:n {#3}
    \__wisper_idxrange_aux:nnn {#1} {#2} {#3}
    % if this was the last item, stop now and do not append a comma
    \quark_if_recursion_tail_stop:n {#4}
    % else append the comma
    ,
    \__wisper_idxrange_aux:nnnn {#1} {#2} {#4}
  }
\cs_new:Npn \__wisper_idxrange_aux:nnn #1#2#3
  {
    \tl_if_eq:nnTF {#3} {.}
      { \dots }
      {
        \IfBooleanTF {#1}
          {
            % starred version of the command
            \tl_set:Nn \idx {#3}
            {#2}
          }
          {
            % non-starred
            {#2} \c_math_subscript_token {#3}
          }
      }
  }

% complex numbers [[[1
\cs_gset:Npn \Conj #1
  { #1 \c_math_superscript_token { \ast } }
\cs_new:Npn \HC
  { \mathrm{h.c.} }


% vectors etc. [[[1


% From https://tex.stackexchange.com/questions/44017/dot-notation-for-derivative-of-a-vector/44071#44071
% --- Macro \xvec
\ExplSyntaxOff
\expandafter \def \csname __wisper_xvec_tikzpicture:nn\endcsname #1#2%
  {%
    % #1 is width
    % #2 are the dot locations
    \begin{tikzpicture}[scale=1]%
        \pgfsetroundcap%
        %\draw[-{Stealth[width=0.1em, length=0.075em, slant=.3]}] (.05em,0)--(\xvec@width-.05em,0);
        %\draw[-{Straight Barb[left,width=0.1em, length=0.075em, slant=.3]}] (.05em,0)--(\xvec@width-.05em,0);
        \draw[-{Classical TikZ Rightarrow[width=0.2em, length=0.15em, slant=.3]}] (.05em,0)--(#1-.05em,0);%
        %\draw[-{Classical TikZ Rightarrow[left, width=0.2em, length=0.1em, slant=.3]}] (.05em,0)--(\xvec@width-.05em,0);
        %\draw (\xvec@width-.05em,0)--(\xvec@width-.15em, .075em);
        %\draw (\xvec@width-.05em,0)--(\xvec@width-.15em,-.075em);
        \foreach \x in {#2}%
          \fill(#1*\x,.5ex) circle (.6pt);%
    \end{tikzpicture}%%
  }%
\ExplSyntaxOn
\cs_generate_variant:Nn \__wisper_xvec_tikzpicture:nn { nf }
\dim_new:N \l__wisper_xvec_ht_dim
\dim_new:N \l__wisper_xvec_dp_dim
\dim_new:N \l__wisper_xvec_wd_dim
\cs_new:Npn \xvec #1#2
  {
    \mode_if_math:TF
      %{ \hbox_set:Nn \l_tmpa_box {#2} }
      { \hbox_set:Nn \l_tmpa_box {$#2$} }
      { \hbox_set:Nn \l_tmpa_box {$#2$} }
    \dim_set:Nn \l__wisper_xvec_ht_dim { \box_ht:N \l_tmpa_box }
    %\dim_set:Nn \l__wisper_xvec_dp_dim { \box_dp:N \l_tmpa_box }
    \dim_set:Nn \l__wisper_xvec_wd_dim { \box_wd:N \l_tmpa_box }

    \box_move_up:nn { \l__wisper_xvec_ht_dim + .1ex }
      {
        \hbox_overlap_right:n
          {
            \kern.05em%  (Because left edge of drawing is at .05em)
            \__wisper_xvec_tikzpicture:nf
              { \l__wisper_xvec_wd_dim }
              {
                \str_if_eq:nnT {#1} {.} {.45}
                \str_if_eq:nnT {#1} {:} {.30, .65}
              }
          }
      }
    #2
  }

% Override \vec with an either invocation of \xvec or \bm

\cs_new_eq:NN \stdvec \vec

% TODO: maybe use a property to store the code in order to avoid doubling the '##'
\__wisper_keys_define_math:n
  {
    vecdisplay .choice:,
    vecdisplay / std .code:n =
      {
        \cs_gset_eq:NN \vec \stdvec
        \cs_gset:Npn \uvec ##1 { \hat{\vec{##1}} }
        \cs_gset:Npn \dvec ##1 { \dot{\vec{##1}} }
        \cs_gset:Npn \ddvec ##1 { \ddot{\vec{##1}} }
      },
    vecdisplay / xvec .code:n =
      {
        \cs_gset:Npn \vec ##1 { \xvec{}{##1} }
        \cs_gset:Npn \uvec ##1 { \hat{\xvec{}{##1}} }
        \cs_gset:Npn \dvec ##1 { \xvec{.}{##1} }
        \cs_gset:Npn \ddvec ##1 { \xvec{:}{##1} }
      },
    vecdisplay / bold .meta:n =
      {
        % for some fonts, \bm doesn't do the right thing
        % Maybe \bm does do the right thing after all, the problem was likely due
        % to a messed-up preamble
        % TODO: Automatically select the correct command based on the font
        vecdisplay / bm
      },
    vecdisplay / bm .code:n =
      {
        \cs_gset_eq:NN \vec \bm
        \cs_gset:Npn \uvec ##1 { \bm{\hat{##1}} }
        \cs_gset:Npn \dvec ##1 { \dot{\bm{##1}} }
        \cs_gset:Npn \ddvec ##1 { \ddot{\bm{##1}} }
      },
    vecdisplay / mathbold .code:n =
      {
        \cs_gset_eq:NN \vec \mathbold
        \cs_gset:Npn \uvec ##1 { \mathbold{\hat{##1}} }
        \cs_gset:Npn \dvec ##1 { \dot{\mathbold{##1}} }
        \cs_gset:Npn \ddvec ##1 { \ddot{\mathbold{##1}} }
      },
    vecdisplay .initial:n = bold,
  }

% shorthand
\cs_gset_eq:NN \vc \vec
\cs_gset_eq:NN \dvc \dvec
\cs_gset_eq:NN \ddvc \ddvec
\cs_gset_eq:NN \uvc \uvec

\__wisper_key_define_surrounding:nnn { colvec / surrounding }
  { __wisper_colvec_surrounding }
  { parenthesis-alt }
\NewDocumentCommand \colvec { o m }
  {
    \IfNoValueTF { #1 }
      {
        \__wisper_colvec_surrounding_resize:n
          { \begin{matrix} #2 \end{matrix} }
      }
      {
        % with column spec
        \__wisper_colvec_surrounding_resize:n
        { \begin{matrix*}[#1] #2 \end{matrix*} }
      }
  }


%\DeclareMathOperator { \__wisper_operator_dim: } { dim }
\cs_gset_eq:NN \__wisper_operator_dim: \dim
\NewDocumentCommand \Dim { s m }
  {
    \__wisper_operator_dim: \__wisper_parenthesize:nn {#1} {#2}
  }
\DeclareMathOperator { \__wisper_operator_span: } { span }
\NewDocumentCommand \Span { s m }
  {
    \__wisper_operator_span: \__wisper_parenthesize:nn {#1} {#2}
  }

% Integrals [[[1
\__wisper_keys_define_math:n
  {
    integrate/displayfunc .choice:,
    integrate/displayfunc / inset .code:n =
      {
        \cs_gset:Npn \__wisper_integrate_integrand:nnnn ##1##2##3##4
          { ##4 \mathop{} \! \__wisper_dif:nnnn {##1} {\BooleanFalse} {##3} {##2} }
      },
    integrate/displayfunc / outset .code:n =
      {
        \cs_gset:Npn \__wisper_integrate_integrand:nnnn ##1##2##3##4
          { \! \__wisper_dif:nnnn {##1} {\BooleanFalse} {##3} {##2} \mathop{} \! ##4 }
      },
    integrate/displayfunc .initial:n = inset,
    % shorthands
    integrate / outset .meta:n = { integrate/displayfunc = outset },
    integrate / inset .meta:n = { integrate/displayfunc = inset },
  }

\NewDocumentCommand \__wisper_integrate_aux:nnnnn { >{\SplitArgument{1}{^}}m m m m m }
  {
    \IfNoValueTF{#2}
      {\int}
      {\IfNoValueTF{#3}%
          {\int \c_math_subscript_token {#2}}
          {\int \c_math_subscript_token {#2} \c_math_superscript_token {#3}}
      }
    \__wisper_integrate_integrand:nnnn {#4} #1 {#5}
  }

\NewDocumentCommand \__wisper_integrate:nn { >{ \SplitArgument{2}{;} } m m }
  { \__wisper_integrate_aux:nnnnn #1 {} {#2} }
\NewDocumentCommand \__wisper_integrate:nw { >{ \SplitArgument{2}{;} } r() m }
  { \__wisper_integrate_aux:nnnnn #1 { \__wisper_parenthesize_aux:w } {#2} }
\DeclareDocumentCommand \Integrate { o }
  {
    \IfValueT {#1} { \__wisper_keys_set_math:nn {integrate} {#1} }
    \peek_charcode_ignore_spaces:NTF (
      { \__wisper_integrate:nw }
      { \__wisper_integrate:nn }
  }
\cs_gset_eq:NN \Int \Integrate


% TODO: \Int{f}{x,1,3;y,0,10}
% TODO: \Iint, \Iiint, \Iiiint, \Idotsint{f(x_1,\ldots,x_n)}{x_1,0,\infty;...;x_j,\R;...;x_n,0,\infty}
% TODO: \Infimum, \Supremum, \Limes

% Other 'Big' operators [[[1
\cs_new:Npn \__wisper_operator_with_limits:Nnnnnn #1#2#3#4#5#6
  {
    #1
    \bool_if:nT {#2 && (!\__wisper_tl_if_novalue_or_blank_p:n {#4} || !\__wisper_tl_if_novalue_or_blank_p:n {#6}) }
      {
        % only add this if there's a sub- or superscript to show
        \limits
      }
    \__wisper_tl_if_novalue_or_blank:nF {#4}
      {
        \c_math_subscript_token
          {
            \use_none:n #4  % absorb \c_empty_tl
            \__wisper_tl_if_novalue_or_blank:nF {#5}
              { = #5 }
          }
      }
    \__wisper_tl_if_novalue_or_blank:nF {#6}
      {
        \c_math_superscript_token {#6}
      }
    #3
  }
% Hack to preserve braces wrapping the optional argument, cf.
% https://tex.stackexchange.com/questions/465970/prevent-xparse-from-stripping-braces 
\NewDocumentCommand \__wisper_operator_with_limits:Nnwn
  { m m >{\SplitArgument{2}{;}} O{ {\c_empty_tl} {} {} } m }
  {
    \__wisper_operator_with_limits:Nnnnnn #1 { #2 } { #4 } #3
  }
\cs_new:Npn \__wisper_declare_big_operator_with_limits:NN #1#2
  {
    \DeclareDocumentCommand #1 { s t[ }
      {
        % Starred version uses \limits
        \IfBooleanTF {##2}
          { \__wisper_operator_with_limits:Nnwn #2 {##1} [ \c_empty_tl }
          { \__wisper_operator_with_limits:Nnwn #2 {##1} }
      }
  }
\__wisper_declare_big_operator_with_limits:NN \Prod \prod
\__wisper_declare_big_operator_with_limits:NN \Sum \sum
\__wisper_declare_big_operator_with_limits:NN \Coprod \coprod
\__wisper_declare_big_operator_with_limits:NN \DirectSum \bigoplus
\__wisper_declare_big_operator_with_limits:NN \TensorProd \bigotimes
%\__wisper_declare_big_operator_with_limits:NN \Bigodot \bigodot
\__wisper_declare_big_operator_with_limits:NN \Union \bigcup
\__wisper_declare_big_operator_with_limits:NN \Intersection \bigcap
%\__wisper_declare_big_operator_with_limits:NN \Biguplus \biguplus
%\__wisper_declare_big_operator_with_limits:NN \Bigsqcup \bigsqcup
%\__wisper_declare_big_operator_with_limits:NN \Bigvee \bigvee
%\__wisper_declare_big_operator_with_limits:NN \Bigwedge \bigwedge


% combinatorics [[[1
% \bincoef{N \\ k}
\cs_new:Npn \bincoef #1
  { \colvec {#1} }

% operators [[[1
\NewDocumentCommand \Adjoint { m } { #1^\dagger }
\cs_new_eq:NN \Adj \Adjoint
\NewDocumentCommand \Operator { m } { \hat{#1} }
\cs_new_eq:NN \Op \Operator

\cs_new_eq:NN \composed \circ


% vector calculus [[[1
\__wisper_keys_define_math:n
  {
    calculus/laplacian/symbol .choice:,
    calculus/laplacian/symbol / nabla .code:n =
      { \tl_gset:Nn \__wisper_laplacian_symbol_tl { \nabla^2 } },
    calculus/laplacian/symbol / delta .code:n =
      { \tl_gset:Nn \__wisper_laplacian_symbol_tl { \Delta } },
    calculus/laplacian/symbol .initial:n = delta,

    % shorthands
    laplacian-nabla .meta:n = { calculus/laplacian/symbol = nabla },
    laplacian-delta .meta:n = { calculus/laplacian/symbol = delta },
  }
\NewDocumentCommand \Gradient
  { m } { \nabla {#1} }  % not a vector!
\cs_gset_eq:NN \Grad \Gradient

\NewDocumentCommand \Divergence { m }
  { \vec{\nabla} \cdot {#1} }
\cs_gset_eq:NN \Div \Divergence

\RenewDocumentCommand \Curl { m }
  { \vec{\nabla} \times {#1} }

\RenewDocumentCommand \Laplacian { m }
  { \__wisper_laplacian_symbol_tl {#1} }  % not a vector!
%\newcommand{\laplacian}{\Delta}


% calculus [[[1

% Differential symbol for use in integrals or in differential forms
% no-op helper
\cs_new:Npn \nodifspacing #1 {#1}
\cs_new:Npn \__wisper_dif_spacing:nn #1
  {
    \IfBooleanTF{#1}
      {\nodifspacing}
      {\mathinner}
  }
\cs_new_protected:Npn \__wisper_difsymbol_process_variable_aux:w #1^#2 #3 \q_stop
  {
    \if_meaning:w \q_mark #2
      \tl_gset_eq:NN \l__wisper_dif_exponent_tl \c_novalue_tl
      \tl_gset:Nn \l__wisper_dif_variable_tl { #1 }
    \else:
      \tl_gset:Nn \l__wisper_dif_exponent_tl { #2 }
      \tl_gset:Nn \l__wisper_dif_variable_tl { #1 }
    \fi:
  }
\cs_new_protected:Npn \__wisper_difsymbol:NNnnn #1#2#3#4#5
  {
    % #1 - the symbol
    % #2 - surrounding
    % #3 - boolean: whether to disable automatic spacing
    % #4 - the exponent (possibly \NoValue)
    % #5 - the variable
    \tl_if_novalue:nTF {#4}
      {
        % If there's no superscript token directly at the \dif, possibly
        % collect one from the variable
        \__wisper_difsymbol_process_variable_aux:w #5 ^ \q_mark \q_stop
      }
      {
        \tl_set:Nn \l__wisper_dif_variable_tl { #5 }
        \tl_set:Nn \l__wisper_dif_exponent_tl { #4 }
      }
    \tl_if_novalue:nTF {#5}
      {
        % Never apply spacing if no argument is given
        #1
        \tl_if_novalue:VF \l__wisper_dif_exponent_tl
          { \c_math_superscript_token {\l__wisper_dif_exponent_tl} }
      }
      {
        \__wisper_dif_spacing:nn {#3}
          {
            #1
            \tl_if_novalue:VF \l__wisper_dif_exponent_tl
              { \c_math_superscript_token {\l__wisper_dif_exponent_tl} }
            #2 { \l__wisper_dif_variable_tl }
          }
      }
  }
\cs_new:Npn \__wisper_declare_difsymbol:nN #1#2
  {
    \cs_new:cpn { __wisper_ #1 :nnnn }
      {
        % #1 - surrounding
        % #2 - disable spacing
        % #3 - exponent
        % #4 - variable
        \__wisper_difsymbol:NNnnn #2
      }
    \__wisper_new_document_command:cnn { __wisper_ #1 _normal:nnn } { m m g }
      { \__wisper_difsymbol:NNnnn #2 \__wisper_surround_none:w {##1} {##2} {##3} }
    \__wisper_new_document_command:cnn { __wisper_ #1 _long:nnw } { m m r() }
      { \__wisper_difsymbol:NNnnn #2 \__wisper_parenthesize_aux:w  {##1} {##2} {##3} }
    \__wisper_new_document_command:cnn { #1 } { s e{^} }
      % Full syntax:
      % \dif^3 {x}
      % \dif {x^3}
      % \dif^3 (x)
      % \dif (x^3)
      % \dif*^3 {x}
      % \dif* {x^3}
      % \dif*^3 (x)
      % \dif* (x^3)
      % {##1} star (disable spacing)
      {
        \peek_charcode_ignore_spaces:NTF (
          { \use:c { __wisper_ #1 _long:nnw } {##1} {##2} }
          { \use:c { __wisper_ #1 _normal:nnn } {##1} {##2} }
      }
  }
\__wisper_declare_difsymbol:nN {dif} \diffd
\__wisper_declare_difsymbol:nN {Dif} \diffD
\__wisper_declare_difsymbol:nN {del} \partial
\__wisper_declare_difsymbol:nN {var} \delta

% Lebesgue formalism
\newcommand{\leb}{\ensuremath{\lambda}}

% functions [[[1
\newcommand{\func}[1]{\mathrm{#1}}
\newcommand{\expp}[1]{\func{e}^{#1}}
\newcommand{\expb}[1]{\exp\left(#1\right)}
\newcommand{\deltaf}[1]{\func{\delta} (#1)}
\DeclareMathOperator{\asinh}{asinh}

\DeclareMathOperator \__wisper_operator_exp: {exp}
\DeclareMathOperator \__wisper_operator_log: {ln}
%\DeclareDocumentCommand { s e{^} d() g } \Exp
%  {
%    % #1 - starred, i.e. whether to resize delimiters
%    % #2 - \Exp^{value} notation. FIXME: implement
%    % #3 - \Exp(value) notation to get surrounding parenthesis
%    % #4 - \Exp{value} notation
%    \IfValueTF {#2}
%      { \msg_error: }
%      {
%        \IfValueTF {#3}
%          { \__wisper_operator_exp: \__wisper_parenthesize:nn {#1} {#3} }
%          {
%            \IfValueT {#4}
%              { \__wisper_operator_exp: {#3} }
%          }
%      }
%  }
\NewDocumentCommand \__wisper_operator_exp_power:w { s e{^} }
  {
    \IfValueT {#2}
      { e^{#2} }
  }
\NewDocumentCommand \__wisper_operator_exp_parens:nnw { m m r() }
  { \__wisper_operator_exp: \__wisper_parenthesize:nnn {#1} {#2} {#3} }
\NewDocumentCommand \__wisper_operator_exp_parens:nnn { m m m }
  { \__wisper_operator_exp: \__wisper_parenthesize:nnn {#1} {#2} {#3} }
\NewDocumentCommand \__wisper_operator_exp:ww { s o }
  {
    \peek_charcode_ignore_spaces:NTF ^
      { \__wisper_operator_exp_power:w }
      {
        \peek_charcode_ignore_spaces:NTF ( %)
          { \__wisper_operator_exp_parens:nnw {#1} {#2} }
          { \__wisper_operator_exp_parens:nnn {#1} {#2} }
      }
  }
\cs_gset_eq:NN \Exp \__wisper_operator_exp:ww

\NewDocumentCommand \__wisper_operator_log_parens:nw { m r() }
  { \__wisper_operator_log: \__wisper_parenthesize:nn {#1} {#2} }
\NewDocumentCommand \__wisper_operator_log_nodelim:n { m }
  { \__wisper_operator_log: {#1} }
\NewDocumentCommand \__wisper_operator_log:ww { s }
  {
    \peek_charcode_ignore_spaces:NTF ( %)
      { \__wisper_operator_log_parens:nw {#1} }
      { \__wisper_operator_log_nodelim:n }
  }
\cs_gset_eq:NN \Log \__wisper_operator_log:ww

% replace the useless Max{} from the `cool` package
\RenewDocumentCommand \Max { m m }
  {
    \max \c_math_subscript_token {#2} \; {#1}
  }

% Derivatives [[[1

% TODO: Starred version of the command that disables all of the exponent processing
% example: \deriv{\dif}{f}{x^2;y^3}
% example: \deriv{\partial}{f}{x^n;y^m}[n+m]  with an optional argument to overwrite the count
\cs_new_protected:Npn \__wisper_deriv_process_denominator_aux:w #1^#2 #3 \q_stop
  {
    \if_meaning:w \q_mark #2
      \int_incr:N \l__wisper_derivative_order_int 
    \else:
      \__wisper_if_integer:xTF {#2}
        { \int_add:Nn \l__wisper_derivative_order_int {#2} }
        { \seq_put_right:Nx \l_non_integer_order_seq {#2} }
    \fi:
  }

\cs_new_protected:Npn \__wisper_derivative:NNnnn #1#2#3#4#5
  {
    % #1 - command to wrap the result in (i.e. parenthesis, ...)
    % #2 - deriv sign
    % #3 - function
    % #4 - exponent overwrite for non-numerical cases
    % #5 - semicolon-separated list of variables, exponents given as usual with ^
    % wrap in a group such that the counter is properly scoped when nesting
    % derivatives (TODO: verify that nesting works)
    \group_begin:

    \int_zero_new:N \l__wisper_derivative_order_int
    \seq_clear_new:N \l_non_integer_order_seq
    \tl_clear_new:N \l_numerator_tl
    \tl_clear_new:N \l_denominator_tl

    % Construct denominator, sum up exponents
    \__wisper_clist_map_inline_no_unbrace:nn {#5}
      {
        \tl_put_right:Nn \l_denominator_tl {\mathop{}\!#2 {##1}}
        \__wisper_deriv_process_denominator_aux:w ##1 ^ \q_mark \q_stop
      }

    % Construct exponent
    \tl_if_novalue:nTF {#4}
      {
        \tl_set:Nn \l_numerator_tl
          {
            \seq_if_empty:NTF \l_non_integer_order_seq
              {
                \int_compare:nNnTF { \l__wisper_derivative_order_int } { > } { 1 }
                  {
                    #2^{\int_use:N \l__wisper_derivative_order_int} {#3}
                  }
                  {
                    #2 {#3}
                  }
              }
              {
                % TODO: order this sequence and add them if occuring multiple
                % times, i.e. n + n -> 2n
                  #2^{
                      \seq_use:Nn \l_non_integer_order_seq { + }
                      \int_compare:nNnT { \l__wisper_derivative_order_int } { > } { 0 }
                        { + \int_use:N \l__wisper_derivative_order_int }
                    } {#3}
              }
          }
      }
      {
        \tl_set:Nn \l_numerator_tl {#2^{#4} #3}
      }

    % #1 is the command to wrap everything in, e.g. \__wisper_parenthesize_aux:w,
    % the star makes it resize
    #1* {
        % No need to expand these explicitly
        \frac { \l_numerator_tl } { \l_denominator_tl }
      }

    \group_end:
}

\cs_new:Npn \__wisper_define_derivative_command:nN #1#2
  {
    % Use gset since `cool` already defines a \pderiv macro
    % The last two cs' are convenience functions, wrapping in parenthesis resp.
    % brackets
    \__wisper_declare_document_command:cnn {   #1 deriv } { m o m }
      { \__wisper_derivative:NNnnn \__wisper_surround_none:w    #2 {##1} {##2} {##3} }
    \__wisper_declare_document_command:cnn { p #1 deriv } { m o m }
      { \__wisper_derivative:NNnnn \__wisper_parenthesize_aux:w #2 {##1} {##2} {##3} }
    \__wisper_declare_document_command:cnn { b #1 deriv } { m o m }
      { \__wisper_derivative:NNnnn \__wisper_bracketize_aux:w   #2 {##1} {##2} {##3} }
  }

\__wisper_define_derivative_command:nN { t } \dif
\__wisper_define_derivative_command:nN { p } \del
\__wisper_define_derivative_command:nN { f } \var


\DeclarePairedDelimiter \EvaluateNoStar {} {\rvert}
\DeclarePairedDelimiter \EvaluateStar {.} {\rvert}
\DeclareDocumentCommand \Evaluate { s }
  {
    \IfBooleanTF {#1}
      { \EvaluateStar* }
      { \EvaluateNoStar }
  }
\cs_new_eq:NN \Eval \Evaluate

% equation numbering [[[1
%http://tex.stackexchange.com/questions/42726/align-but-show-one-equation-number-at-the-end
\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}


% boxes, highlighting, ... [[[1
% TODO: https://tex.stackexchange.com/questions/20575/attractive-boxed-equations
\definecolor { myblue } { rgb } { .8, .8, 1 }
\cs_new:Npn \__wisper_equation_box:n #1
  { \colorbox { myblue } { \hspace{1em} #1 \hspace{1em} } }
\empheqset{outerbox=\__wisper_equation_box:n}


% Quick quad text (math-mode text with \quad spacing). [[[1
% Idea stolen from the physics package.
\cs_new:Npn \__wisper_q:Nnn #1#2#3
  {
    \IfBooleanF { #2 }
      { \quad }
      #1 {#3}
    \quad
  }

% TODO: only define in math mode (is this possible?)
\NewDocumentCommand \q { s m }
  { \__wisper_q:Nnn \textnormal { #1 } { #2 } }
\NewDocumentCommand \qm { s m }
  { \__wisper_q:Nnn \use:n { #1 } { #2 } }

\ExplSyntaxOff

% vim: ts=2 sw=2 et fdm=marker fmr=[[[,]]]:
