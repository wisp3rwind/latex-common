% TODO: add ensuremath everywhere where appropriate
% TODO: Remove macros already provided by the cool package
% TODO: re-implement physics.sty and braket.sty

\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{cancel}
\usepackage{bm}
\usepackage{cool}
\usepackage{tikz}
\usetikzlibrary{arrows.meta}
\usepackage{xparse}


% Use l3keys to configure style (cf. \Style from the cool package) [[[1
\ExplSyntaxOn

\cs_new:Npn \__wisper_keys_define_math:n #1 { \keys_define:nn { wisper/math } {#1} }
\cs_new:Npn \__wisper_keys_set_math:n #1 { \keys_set:nn { wisper/math } {#1} }
\cs_new_eq:NN \MathStyle \__wisper_keys_set_math:n

% Variants [[[1
%\cs_new:Npn \exp_last_unbraced:NcNo
%  { \::c \::N \::o_unbraced \::: }
%\cs_new:Npn \exp_last_unbraced:NcNo #1#2#3#4
%  { \exp_after:wN #1 \cs:w #2 \exp_after:wN \cs_end: \exp_after:wN #3 #4 }

  % clist tools [[[1
% Copy & pasted \clist_map_inline:nn with slight to prevent unbracing
% the items. Somewhat simplified since I only need one variant (:nn and not :Nn)
\cs_new:Npn \__wisper_null {}  % vanishes after one expansion
\cs_new:Npn \__wisper_clist_map_function_no_unbrace:Nw #1#2 ,
  {
    % The first token in #2 is \__wisper_null, expand that once so it vanishes
    \exp_after:wN \__quark_if_recursion_tail_break:nN
      \exp_after:wN {#2}
      \clist_map_break:
    \exp_after:wN #1
      \exp_after:wN {#2}
    \__wisper_clist_map_function_no_unbrace:Nw #1 \__wisper_null
  }
\cs_new_protected:Npn \__wisper_clist_map_inline_no_unbrace:nn #1#2
  {
    \int_gincr:N \g__prg_map_int
    \cs_gset_protected:cpn
      { __prg_map_ \int_use:N \g__prg_map_int :w } ##1 {#2}
    \exp_args:Nc \__wisper_clist_map_function_no_unbrace:Nw
      { __prg_map_ \int_use:N \g__prg_map_int :w }
      \__wisper_null #1 , \q_recursion_tail ,
    \__prg_break_point:Nn \clist_map_break:
      { \int_gdecr:N \g__prg_map_int }
  }

\ExplSyntaxOff

% helpers [[[1
% TODO: use DeclarePairedDelimiter, also see
% http://tex.stackexchange.com/questions/23178/swap-definition-of-starred-and-non-starred-command/23214#23214
% http://tex.stackexchange.com/questions/278382/cause-declarepaireddelimiter-to-switch-starred-and-nonstarred-versions
% TODO: cf. `texdoc mathtools` for \parenthesize that is breakable
\newcommand{\parenthesize}[1]{{\left(#1\right)}}
\newcommand{\bracketize}[1]{{\left[#1\right]}}

% stolen from the physics package. Starred versions resize the delimiters
\DeclareDocumentCommand \argopen {s}{%
    \IfBooleanTF{#1}
        {\mathopen{}\mathclose\bgroup}
        {\mathopen{}\mathclose\bgroup\left}
}
\DeclareDocumentCommand \argclose {s}{%
    \IfBooleanTF{#1}
        {\egroup}
        {\aftergroup\egroup\right}
}

% symbols [[[1
% TODO: switch according to language, i.e. Spanish is cte.
\newcommand{\diffd}{\mathrm{d}}
\newcommand{\diffD}{\mathrm{D}}
\newcommand{\const}{\mathrm{const}}

\ExplSyntaxOn
% TODO: use for all appropriate operators
\cs_new:Npn \__wisper_argument_or_empty:n #1
  {
    \tl_if_empty:nTF {#1}
      { \: \cdot \: }
      {#1}
  }
\ExplSyntaxOff


% maps [[[1
\ExplSyntaxOn
\DeclareMathOperator {\image} {Im}
\NewDocumentCommand \Image { m }
  {
    \image (#1)
  }

\DeclarePairedDelimiter \__wisper_embrace_aux:n \lbrace \rbrace
\cs_new:Npn \__wisper_embrace:nn #1
  {
    \IfBooleanTF {#1}
      { \__wisper_embrace_aux:n* }
      { \__wisper_embrace_aux:n }
  }
\DeclarePairedDelimiter \__wisper_parenthesize_aux:n \lparen \rparen
\cs_new:Npn \__wisper_parenthesize:nn #1
  {
    \IfBooleanTF {#1}
      { \__wisper_parenthesize_aux:n* }
      { \__wisper_parenthesize_aux:n }
  }
% TODO style variants: \MathStyle{trace-symbol = tr|Tr}
\DeclareMathOperator { \__wisper_operator_trace: } {tr}
% TODO style variants: \MathStyle{trace-parens = parenthesis|curly|square|none}
\NewDocumentCommand \Trace { s }
  { \__wisper_operator_trace: \__wisper_embrace:nn { #1 } }
\cs_gset_eq:NN \Tr \Trace

\tl_new:N \g__wisper_symbol_identity_tl
\prop_new:N \g__wisper_symbol_identity_prop
\prop_put:Nnn \g__wisper_symbol_identity_prop { id } {\mathrm{id}}
\prop_put:Nnn \g__wisper_symbol_identity_prop { 1 } {\mathbb{1}}
\prop_put:Nnn \g__wisper_symbol_identity_prop { I } {\bm{\mathrm{I}}}
\__wisper_keys_define_math:n
  {
    symbols / identity .code:n =
      {
        \prop_if_in:NnTF \g__wisper_symbol_identity_prop {#1}
          {
            \prop_get:NnN \g__wisper_symbol_identity_prop {#1} \g__wisper_symbol_identity_tl
          }
          {
            \msg_error:
          }
      },
    symbols / identity .value_required:n = true,
    symbols / identity .initial:n = I,
  }
\NewDocumentCommand \id { }
  {
    \ensuremath{\g__wisper_symbol_identity_tl}
  }
\ExplSyntaxOff

% misc [[[1
\newcommand{\supposed}{\stackrel{!}{=}}

% sets [[[1
\newcommand{\N}{\ensuremath{\mathbb{N}}}  % natural numbers
\newcommand{\Z}{\ensuremath{\mathbb{Z}}}  % integers
\newcommand{\R}{\ensuremath{\mathbb{R}}}  % real numbers
\newcommand{\Q}{\ensuremath{\mathbb{Q}}}  % rational numbers
\newcommand{\C}{\ensuremath{\mathbb{C}}}  % complex numbers
%\newcommand{\Sphere}{\ensuremath{\mathbb{S}}}  % \S^n \subset \R^{n+1}
\newcommand{\Sphere}{\ensuremath{S}}  % \S^n \subset \R^{n+1}

\newcommand{\nats}{\N} % natural numbers
\newcommand{\natsz}{\ensuremath{\nats_{\mathrm{0}}}} % natural numbers incl. zero

\newcommand{\Pset}[1]{\ensuremath{\mathcal{P}\left(#1\right)}}

\ExplSyntaxOn

\cs_new:Npn \__wisper_mid_vert:n #1
  {
    % TODO: understand this spacing construction (specfically look up \nonscript)
    \nonscript\:
    #1\vert
    \allowbreak
    \nonscript\:
    \mathopen{}
  }

\cs_undefine:N \Set
\DeclarePairedDelimiterX \Set[1] \lbrace \rbrace
  {
    \cs_set:Npn \given { \__wisper_mid_vert:n { \delimsize } }
    \nonscript\, #1 \nonscript\,
  }

\cs_new_eq:NN \union \cup
\cs_new_eq:NN \intersection \cap

\cs_new_eq:NN \Union \bigcup
\cs_new_eq:NN \Intersection \bigcap

\ExplSyntaxOff


% norms etc. [[[1
\ExplSyntaxOn

\cs_undefine:N \Abs
\DeclarePairedDelimiterX \Abs[1] \lvert \rvert
{ \__wisper_argument_or_empty:n {#1} }
\DeclarePairedDelimiterX \Norm[1] \lVert \rVert
{ \__wisper_argument_or_empty:n {#1} }

\ExplSyntaxOff


% Equivalence relations, quotient spaces, ... [[[1
\DeclarePairedDelimiter\EquivalenceClass{\lbrack}{\rbrack}
\let\EqClass\EquivalenceClass


% ranges [[[1
% TODO: let these accept a variable number of initial values, e.g.
% \idxrange{1}[1][2][3][5]{n}
\newcommand{\idxrange}[3]{{#1}_{#2}\dots{#1}_{#3}}
\newcommand{\idxrangec}[3]{{#1}_{#2},\dots,{#1}_{#3}}  % comma-separated
\ExplSyntaxOn
\NewDocumentCommand \Idxrange { s m > { \SplitList { , } } m }
  {
    \__wisper_idxrange_aux:nnnn {#1} {#2} #3 \q_recursion_tail \q_recursion_tail \q_recursion_stop
  }
\cs_new:Npn \__wisper_idxrange_aux:nnnn #1#2#3#4
  {
    %\tl_show:n {#2}
    %\tl_show:n {#3}
    %\tl_show:n {#4}
    \quark_if_recursion_tail_stop:n {#3}
    \__wisper_idxrange_aux:nnn {#1} {#2} {#3}
    % if this was the last item, stop now and do not append a comma
    \quark_if_recursion_tail_stop:n {#4}
    % else append the comma
    ,
    \__wisper_idxrange_aux:nnnn {#1} {#2} {#4}
  }
\cs_new:Npn \__wisper_idxrange_aux:nnn #1#2#3
  {
    \tl_if_eq:nnTF {#3} {.}
      { \dots }
      {
        \IfBooleanTF {#1}
          {
            % starred version of the command
            \tl_set:Nn \idx {#3}
            {#2}
          }
          {
            % non-starred
            {#2} \c_math_subscript_token {#3}
          }
      }
  }
\ExplSyntaxOff

% complex numbers [[[1
\newcommand{\conj}[1]{{#1^{\ast}}}


% vectors etc. [[[1


% From https://tex.stackexchange.com/questions/44017/dot-notation-for-derivative-of-a-vector/44071#44071
% --- Macro \xvec
\makeatletter
\newlength\xvec@height%
\newlength\xvec@depth%
\newlength\xvec@width%
\newcommand{\xvec}[2][]{%
    \ifmmode%
        \settoheight{\xvec@height}{$#2$}%
        \settodepth{\xvec@depth}{$#2$}%
        \settowidth{\xvec@width}{$#2$}%
    \else%
        \settoheight{\xvec@height}{#2}%
        \settodepth{\xvec@depth}{#2}%
        \settowidth{\xvec@width}{#2}%
    \fi%
    \def\xvec@arg{#1}%
    \def\xvec@dd{:}%
    \def\xvec@d{.}%
    \raisebox{.1ex}{\raisebox{\xvec@height}{\rlap{%
        \kern.05em%  (Because left edge of drawing is at .05em)
        \begin{tikzpicture}[scale=1]
            \pgfsetroundcap
            %\draw[-{Stealth[width=0.1em, length=0.075em, slant=.3]}] (.05em,0)--(\xvec@width-.05em,0);
            %\draw[-{Straight Barb[left,width=0.1em, length=0.075em, slant=.3]}] (.05em,0)--(\xvec@width-.05em,0);
            \draw[-{Classical TikZ Rightarrow[width=0.2em, length=0.15em, slant=.3]}] (.05em,0)--(\xvec@width-.05em,0);
            %\draw[-{Classical TikZ Rightarrow[left, width=0.2em, length=0.1em, slant=.3]}] (.05em,0)--(\xvec@width-.05em,0);
            %\draw (\xvec@width-.05em,0)--(\xvec@width-.15em, .075em);
            %\draw (\xvec@width-.05em,0)--(\xvec@width-.15em,-.075em);
            \ifx\xvec@arg\xvec@d%
                \fill(\xvec@width*.45,.5ex) circle (.6pt);%
            \else\ifx\xvec@arg\xvec@dd%
                \fill(\xvec@width*.30,.5ex) circle (.6pt);%
                \fill(\xvec@width*.65,.5ex) circle (.6pt);%
            \fi\fi%
        \end{tikzpicture}%
    }}}%
    #2%
}
\makeatother

% Override \vec with an either invocation of \xvec or \bm
\ExplSyntaxOn

\cs_new_eq:NN \stdvec \vec

% TODO: maybe use a property to store the code in order to avoid doubling the '##'
\__wisper_keys_define_math:n
  {
    vecdisplay .choice:,
    vecdisplay / std .code:n =
      {
        \cs_gset_eq:NN \vec \stdvec
        \cs_gset:Npn \uvec ##1 { \hat{\vec{##1}} }
        \cs_gset:Npn \dvec ##1 { \dot{\vec{##1}} }
        \cs_gset:Npn \ddvec ##1 { \ddot{\vec{##1}} }
      },
    vecdisplay / xvec .code:n =
      {
        \cs_gset_eq:NN \vec \xvec
        \cs_gset:Npn \uvec ##1 { \hat{\xvec{##1}} }
        \cs_gset:Npn \dvec ##1 { \xvec[.]{##1} }
        \cs_gset:Npn \ddvec ##1 { \xvec[:]{##1} }
      },
    vecdisplay / bold .meta:n =
      {
        % for some fonts, \bm doesn't do the right thing
        % Maybe \bm does do the right thing after all, the problem was likely due
        % to a messed-up preamble
        % TODO: Automatically select the correct command based on the font
        vecdisplay / bm
      },
    vecdisplay / bm .code:n =
      {
        \cs_gset_eq:NN \vec \bm
        \cs_gset:Npn \uvec ##1 { \bm{\hat{##1}} }
        \cs_gset:Npn \dvec ##1 { \dot{\bm{##1}} }
        \cs_gset:Npn \ddvec ##1 { \ddot{\bm{##1}} }
      },
    vecdisplay / mathbold .code:n =
      {
        \cs_gset_eq:NN \vec \mathbold
        \cs_gset:Npn \uvec ##1 { \mathbold{\hat{##1}} }
        \cs_gset:Npn \dvec ##1 { \dot{\mathbold{##1}} }
        \cs_gset:Npn \ddvec ##1 { \ddot{\mathbold{##1}} }
      },
    vecdisplay .initial:n = bold,
  }

% shorthand
\newcommand\vc{\vec}
\newcommand\dvc{\dvec}
\newcommand\ddvc{\ddvec}
\newcommand\uvc{\uvec}

\newcommand{\colvec}[1]{\begin{pmatrix}#1\end{pmatrix}}


%\DeclareMathOperator {\dim} {dim}
\NewDocumentCommand \Dim { m }
  { \dim (#1) }
\DeclareMathOperator {\spanX} {span}
\NewDocumentCommand \Span { m }
  { \spanX (#1) }

\__wisper_keys_define_math:n
  {
    integrate/displayfunc .choice:,
    integrate/displayfunc / inset .code:n =
      {
        \cs_gset:Npn \__wisper_integrate_integrand:nnn ##1##2##3
          {##1 \mathop{}\!\expandafter\dif\IfValueT{##3}{[##3]}{##2}}
      },
    integrate/displayfunc / outset .code:n =
      {
        \cs_gset:Npn \__wisper_integrate_integrand:nnn ##1##2##3
          {\!\expandafter\dif\IfValueT{##3}{[##3]}{##2}\mathop{}\! ##1}
      },
    integrate/displayfunc .initial:n = inset,
  }

\NewDocumentCommand \IntegrateInternal { >{\SplitArgument{1}{^}}m m m m }
  {
    \IfNoValueTF{#2}
      {\int}
      {\IfNoValueTF{#3}%
          {\int \c_math_subscript_token {#2}}
          {\int \c_math_subscript_token {#2} \c_math_superscript_token {#3}}
      }
    \__wisper_integrate_integrand:nnn {#4} #1
  }

\DeclareDocumentCommand \Integrate{ >{\SplitArgument{2}{,}}m m }{%
    \IntegrateInternal #1 {#2}
}

\cs_gset_eq:NN \Int \Integrate

\ExplSyntaxOff

% TODO: port \Sum and \Prod, too, and write starred versions that use \limits
% TODO: \Int{f}{x,1,3;y,0,10}
% TODO: \Iint, \Iiint, \Iiiint, \Idotsint{f(x_1,\ldots,x_n)}{x_1,0,\infty;...;x_j,\R;...;x_n,0,\infty}
% TODO: \Union, \Intersection, \Infimum, \Supremum, \Limes

% COOL prints the '=' also if the second argument is empty...
\NewDocumentCommand\SumInternal{m m m m}{%
    \sum%
    \IfValueT{#2}{_%
        {#2\IfValueT{#3}{%
            \if\relax\detokenize{#3}\relax%
            \else%
                = #3%
            \fi}}%
        }%
    \IfValueT{#4}{^{#4}}%
    #1%
}
\DeclareDocumentCommand\Sum{ >{\SplitArgument{2}{,}} m m }{%
    \SumInternal{#2}#1
}

% combinatorics [[[1
% \bincoef{N \\ k}
\newcommand{\bincoef}[1]{\ensuremath{\begin{pmatrix} #1 \end{pmatrix}}}

% operators [[[1
\ExplSyntaxOn
\NewDocumentCommand \Adjoint { m } { {#1}^\dagger }
\cs_new_eq:NN \Adj \Adjoint
\NewDocumentCommand \Operator { m } { \hat{#1} }
\cs_new_eq:NN \Op \Operator

\cs_new_eq:NN \composed \circ

\ExplSyntaxOff

% vector calculus [[[1
\ExplSyntaxOn

\NewDocumentCommand \Gradient { m } { \nabla {#1} }  % not a vector! -> non-bold
\cs_gset_eq:NN \Grad \Gradient

\NewDocumentCommand \Divergence { m } { \vec{\nabla} \cdot {#1} }
\cs_gset_eq:NN \Div \Divergence

\RenewDocumentCommand \Curl { m } { \vec{\nabla} \times {#1} }

\RenewDocumentCommand \Laplacian { m } { \nabla^2 {#1} }  % not a vector! -> non-bold
%\newcommand{\laplacian}{\Delta}
\ExplSyntaxOff


% calculus [[[1

% no-op helper
\NewDocumentCommand\nodifspacing{m}{#1}

% Differential symbol for use in integrals or in differential forms
\NewDocumentCommand\difsymbol{m m o g d()}{%
%\NewDocumentCommand\difsymbol{s m m o g d()}{%
    % {#1} - (star) unstarred: dx³, starred: d³x
    % {#2} - boolean: whether to disable automatic spacing
    % {#3} - the symbol
    % [--] - optional exponent, e.g. d^3 r
    % {#4} - the variable
    % (#5) - long form, e.g. d(cos x)
    \IfBooleanTF{#1}{\let\difspacing\nodifspacing}{\let\difspacing\mathinner}
    \IfNoValueTF{#4}{%
        \IfNoValueTF{#5}{%
% Never apply spacing if no argument is given
            #2 \IfValueT{#3}{^{#3}}
        }{%
% long form
            \difspacing{#2 \IfValueT{#3}{^{#3}} (#5)}
        }
    }{%
% normal form
        \difspacing{#2 \IfValueT{#3}{^{#3}} #4}
    }
}
\DeclareDocumentCommand\dif{s}{\difsymbol{#1}{\diffd}}
\DeclareDocumentCommand\Dif{s}{\difsymbol{#1}{\diffD}}
\DeclareDocumentCommand\del{s}{\difsymbol{#1}{\partial}}
\DeclareDocumentCommand\var{s}{\difsymbol{#1}{\delta}}

% Lebesgue formalism
\newcommand{\leb}{\ensuremath{\lambda}}

% functions [[[1
\newcommand{\func}[1]{\mathrm{#1}}
\newcommand{\expp}[1]{\func{e}^{#1}}
\newcommand{\expb}[1]{\exp\left(#1\right)}
\newcommand{\deltaf}[1]{\func{\delta} (#1)}
\DeclareMathOperator{\asinh}{asinh}

\ExplSyntaxOn
\DeclareMathOperator \__wisper_operator_exp: {exp}
\DeclareMathOperator \__wisper_operator_log: {ln}
%\DeclareDocumentCommand { s e{^} d() g } \Exp
%  {
%    % #1 - starred, i.e. whether to resize delimiters
%    % #2 - \Exp^{value} notation. FIXME: implement
%    % #3 - \Exp(value) notation to get surrounding parenthesis
%    % #4 - \Exp{value} notation
%    \IfValueTF {#2}
%      { \msg_error: }
%      {
%        \IfValueTF {#3}
%          { \__wisper_operator_exp: \__wisper_parenthesize:nn {#1} {#3} }
%          {
%            \IfValueT {#4}
%              { \__wisper_operator_exp: {#3} }
%          }
%      }
%  }
\NewDocumentCommand \__wisper_operator_exp_power:w { s e{^} }
  {
    \IfValueT {#2}
      { e^{#2} }
  }
\NewDocumentCommand \__wisper_operator_exp_parens:ww { m r() }
  { \__wisper_operator_exp: \__wisper_parenthesize:nn {#1} {#2} }
\NewDocumentCommand \__wisper_operator_exp_parens:wn { m m }
  { \__wisper_operator_exp: \__wisper_parenthesize:nn {#1} {#2} }
\NewDocumentCommand \__wisper_operator_exp:ww { s }
  {
    \peek_charcode_ignore_spaces:NTF ^
      { \__wisper_operator_exp_power:w }
      {
        \peek_charcode_ignore_spaces:NTF ( %)
          { \__wisper_operator_exp_parens:ww {#1} }
          { \__wisper_operator_exp_parens:wn {#1} }
      }
  }
\cs_gset_eq:NN \Exp \__wisper_operator_exp:ww

\NewDocumentCommand \__wisper_operator_log_parens:nw { m r() }
  { \__wisper_operator_log: \__wisper_parenthesize:nn {#1} {#2} }
\NewDocumentCommand \__wisper_operator_log_nodelim:n { m }
  { \__wisper_operator_log: {#1} }
\NewDocumentCommand \__wisper_operator_log:ww { s }
  {
    \peek_charcode_ignore_spaces:NTF ( %)
      { \__wisper_operator_log_parens:nw {#1} }
      { \__wisper_operator_log_nodelim:n }
  }
\cs_gset_eq:NN \Log \__wisper_operator_log:ww
\ExplSyntaxOff

% replace the useless Max{} from the `cool` package
\RenewDocumentCommand\Max{m m}{%
    \max_{#2} \; {#1}%
}

% Derivatives [[[1

% Use gset since `cool` already defines a \pderiv macro
\ExplSyntaxOn
\cs_new:Npn \defineDerivateCommand #1#2
{
    \cs_gset:cpn {#1 deriv} {\deriv{#2}}
    % for convenience, wrap in parenthesis
    \cs_gset:cpn {p #1 deriv} {\deriv[\parenthesize]{#2}}
    % for convenience, wrap in brackets
    \cs_gset:cpn {b #1 deriv} {\deriv[\bracketize]{#2}}
}
\defineDerivateCommand{t}{\dif}
\defineDerivateCommand{p}{\del}
\defineDerivateCommand{f}{\delta}
\ExplSyntaxOff

%------------------------------------------------------------

\ExplSyntaxOn
\regex_gset:Nn \g__wisper_integer_regex { [+-]?\d+ }
\prg_new_protected_conditional:Npnn \__wisper_if_integer:n #1 { T, F, TF }
  {
    \regex_match:NnTF \g__wisper_integer_regex {#1}
      { \prg_return_true: }
      { \prg_return_false: }
  }
\cs_generate_variant:Nn \__wisper_if_integer:nTF { xTF }
\ExplSyntaxOff

% TODO: Starred version of the command that disables all of the exponent processing
% example: \deriv{\dif}{f}{x^2;y^3}
% example: \deriv{\partial}{f}{x^n;y^m}[n+m]  with an optional argument to overwrite the count
\ExplSyntaxOn
\int_new:N \l__wisper_derivative_order_int
\cs_new_protected:Npn \__wisper_deriv_process_denominator_aux:w #1^#2 #3 \q_stop
  {
    %\tl_show:n {#1}
    %\tl_show:n {#2}
    %\tl_show:n {#3}
    \if_meaning:w \q_mark #2
      \int_incr:N \l__wisper_derivative_order_int 
    \else:
      \__wisper_if_integer:xTF {#2}
        { \int_add:Nn \l__wisper_derivative_order_int {#2} }
        { \seq_put_right:Nx \l_non_integer_order_seq {#2} }
    \fi:
  }
\NewDocumentCommand \deriv {o m m o m} {%
    % #1 - command to wrap the result in (i.e. parenthesis, ...)
    % #2 - deriv sign
    % #3 - function
    % #4 - exponent overwrite for non-numerical cases
    % #5 - semicolon-separated list of variables, exponents given as usual with ^
    % wrap in a group such that the counter is properly scoped when nesting
    % derivatives (TODO: verify that nesting works)
    \group_begin:

    \int_zero:N \l__wisper_derivative_order_int
    \seq_clear_new:N \l_non_integer_order_seq
    \tl_clear_new:N \l_numerator_tl
    \tl_clear_new:N \l_denominator_tl

    % Construct denominator, sum up exponents
    \__wisper_clist_map_inline_no_unbrace:nn {#5}
      {
        %\tl_show:n {##1}
        \tl_put_right:Nn \l_denominator_tl {\mathop{}\!#2 ##1}
        \__wisper_deriv_process_denominator_aux:w ##1 ^ \q_mark \q_stop
      }

    % Construct exponent
    \IfNoValueTF{#4}
      {
        \tl_set:Nn \l_numerator_tl
          {
            \seq_if_empty:NTF \l_non_integer_order_seq
              {
                \int_compare:nNnTF { \l__wisper_derivative_order_int } { > } { 1 }
                  {
                    #2[\int_use:N \l__wisper_derivative_order_int] #3
                  }
                  {
                    #2 #3
                  }
              }
              {
                % TODO: order this sequence and add them if occuring multiple
                % times, i.e. n + n -> 2n
                  #2[
                      \seq_use:Nn \l_non_integer_order_seq { + }
                      \int_compare:nNnT { \l__wisper_derivative_order_int } { > } { 0 }
                        { + \int_use:N \l__wisper_derivative_order_int }
                    ] #3
              }
          }
      }
      {
        \tl_set:Nn \l_numerator_tl {#2[#4] #3}
      }

    \IfValueT{#1}{#1}
      {
        % No need to expand these explicitly
        \frac { \l_numerator_tl } { \l_denominator_tl }
      }

    \group_end:
}


\DeclarePairedDelimiter \EvaluateNoStar {} {\rvert}
\DeclarePairedDelimiter \EvaluateStar {.} {\rvert}
\DeclareDocumentCommand \Evaluate { s }
  {
    \IfBooleanTF {#1}
      { \EvaluateStar* }
      { \EvaluateNoStar }
  }
\cs_new_eq:NN \Eval \Evaluate
\ExplSyntaxOff

% equation numbering [[[1
%http://tex.stackexchange.com/questions/42726/align-but-show-one-equation-number-at-the-end
\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}


% boxes, highlighting, ... [[[1
% https://tex.stackexchange.com/questions/20575/attractive-boxed-equations


% Quick quad text (math-mode text with \quad spacing). [[[1
% Stolen from the physics package.
\DeclareDocumentCommand\qqmathinternal{m m}{\IfBooleanTF{#1}{}{\quad}{#2}\quad}
\DeclareDocumentCommand\qqtextinternal{m m}{\qqmathinternal{#1}{\textnormal{#2}}}
\DeclareDocumentCommand\qqtext{s m}{\qqtextinternal{#1}{#2}}
\DeclareDocumentCommand\qqmath{s m}{\qqmathinternal{#1}{#2}}

\DeclareDocumentCommand\qq{}{\qqtext}

\DeclareDocumentCommand\qcomma{}{,\quad}
\DeclareDocumentCommand\qc{}{\qcomma}

\DeclareDocumentCommand\qimplies{s}{\qqmathinternal{#1}{\implies}}
\DeclareDocumentCommand\qiff{s}{\qqmathinternal{#1}{\iff}}

\DeclareDocumentCommand\qif{s}{\qqtextinternal{#1}{if}}
\DeclareDocumentCommand\qthen{s}{\qqtextinternal{#1}{then}}
\DeclareDocumentCommand\qelse{s}{\qqtextinternal{#1}{else}}
\DeclareDocumentCommand\qotherwise{s}{\qqtextinternal{#1}{otherwise}}
\DeclareDocumentCommand\qunless{s}{\qqtextinternal{#1}{unless}}
\DeclareDocumentCommand\qgiven{s}{\qqtextinternal{#1}{given}}
\DeclareDocumentCommand\qusing{s}{\qqtextinternal{#1}{using}}
\DeclareDocumentCommand\qassume{s}{\qqtextinternal{#1}{assume}}
\DeclareDocumentCommand\qsince{s}{\qqtextinternal{#1}{since}}
\DeclareDocumentCommand\qlet{s}{\qqtextinternal{#1}{let}}
\DeclareDocumentCommand\qfor{s}{\qqtextinternal{#1}{for}}
\DeclareDocumentCommand\qall{s}{\qqtextinternal{#1}{all}}
\DeclareDocumentCommand\qeven{s}{\qqtextinternal{#1}{even}}
\DeclareDocumentCommand\qodd{s}{\qqtextinternal{#1}{odd}}
\DeclareDocumentCommand\qinteger{s}{\qqtextinternal{#1}{integer}}
\DeclareDocumentCommand\qand{s}{\qqtextinternal{#1}{and}}
\DeclareDocumentCommand\qor{s}{\qqtextinternal{#1}{or}}
\DeclareDocumentCommand\qas{s}{\qqtextinternal{#1}{as}}
\DeclareDocumentCommand\qin{s}{\qqtextinternal{#1}{in}}
\DeclareDocumentCommand\qcc{s}{\qqtextinternal{#1}{c.c.}}

% vim: ts=2 sw=2 et fdm=marker fmr=[[[,]]]:
